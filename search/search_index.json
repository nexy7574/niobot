{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#welcome-to-the-nio-bot-documentation","title":"Welcome to the Nio-Bot Documentation","text":"<p>Warning</p> <p>This documentation is still a work in progress, and is auto-generated from docstrings. If you notice any errors, please open a new issue.</p> <p>Furthermore, the docs are still partially written in sphinx (RST) format. Broken links are to be expected.</p>"},{"location":"#installing","title":"Installing","text":"<p>As this package is not yet on PyPi, you must install from git:</p>"},{"location":"#via-pip","title":"Via pip:","text":"<pre><code>$ pip install git+https://github.com/EEKIM10/niobot.git\n</code></pre>"},{"location":"#in-requirementstxt","title":"In requirements.txt:","text":"<pre><code>niobot[e2ee,cli] @ git+https://github.com/EEKIM10/niobot.giit\n</code></pre>"},{"location":"#cli","title":"CLI","text":"<p>The <code>niobot</code> package comes with a CLI tool, which can be used to create templates, get access tokens, resolve homeservers, and more (in the future).</p> <p>You can install the cli tool with the <code>cli</code> extra. The command itself is <code>niocli</code>.</p>"},{"location":"#version-information","title":"Version information","text":"<p>Version information is found in the <code>__version__.py</code> file, which is created while installing the package.</p> <pre><code>from niobot.__version__ import __version__\nprint(__version__)\n</code></pre>"},{"location":"#logging","title":"Logging","text":"<p>Logging is done using the <code>logging</code> module. The logger is named <code>niobot.&lt;module&gt;</code>. For example:</p> <p><pre><code>import logging\nimport niobot\nlogging.basicConfig(level=logging.INFO)\nbot = niobot.NioBot(...)\nbot.run(...)\n</code></pre> This will now output a bunch of logs to your console, which you can use to debug your bot.</p>"},{"location":"reference/attachment/","title":"Attachments","text":""},{"location":"reference/attachment/#niobot.attachment.Thumbnail","title":"Thumbnail","text":"<p>Represents a thumbnail for a media attachment.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the thumbnail.</p> required <code>mime</code> <code>str</code> <p>The mime type of the thumbnail.</p> required <code>height</code> <code>int</code> <p>The height of the thumbnail.</p> required <code>width</code> <code>int</code> <p>The width of the thumbnail.</p> required <code>size</code> <code>int</code> <p>The size of the thumbnail.</p> required"},{"location":"reference/attachment/#niobot.attachment.Thumbnail.from_attachment","title":"from_attachment  <code>classmethod</code>","text":"<pre><code>from_attachment(attachment: MediaAttachment)\n</code></pre> <p>Creates a thumbnail from a MediaAttachment.</p> <p>You should make sure you've <code>upload()</code>ed the attachment first.</p> <p>Parameters:</p> Name Type Description Default <code>attachment</code> <code>MediaAttachment</code> <p>The attachment to create the thumbnail from.</p> required <p>Returns:</p> Type Description <p>A Thumbnail object.</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment","title":"MediaAttachment","text":"<p>Represents an image, audio or video to be sent to a room.</p> You probably want to skip to from_file <p>The <code>MediaAttachment.from_file</code> method is the best way to create a MediaAttachment from just a file. You should (and realistically, only can) create an instance of this manually if you have the file, mime type, height, width, and optionally thumbnail already.</p> <p>The <code>MediaAttachment.from_file</code> method will automatically do this for you.</p> You can only use video/image/audio content with this class <p>Do not use this attachment type for anything other than video, image, or audio content. Use <code>FileAttachment</code> for other types of files.</p> BytesIO support is experimental <p>It is advised to write BytesIO objects to a temporary file if you experience any issues with them. This is because some methods, such as <code>MediaAttachment.upload</code>, re-open the file descriptor in an asynchronous context, which may cause issues with BytesIO.</p> <p>Initially, the library did this automatically, however to prevent compatibility issues, this is now just the responsibility of the developer.</p> <p>Using a BytesIO() will yield a warning in the logs, however may still work.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to send (either a path, BytesIO, or <code>pathlib.Path</code> object)</p> required <code>mime</code> <code>str</code> <p>The mime type of the file</p> <code>None</code> <code>height</code> <code>typing.Union[int, None]</code> <p>The height of the file, if applicable</p> required <code>width</code> <code>typing.Union[int, None]</code> <p>The width of the file, if applicable</p> required <code>thumbnail</code> <code>Thumbnail</code> <p>The thumbnail of the file, if applicable</p> <code>None</code> <code>blur_hash</code> <code>str</code> <p>The blurhash of the file, if applicable</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.media_type","title":"media_type  <code>property</code>","text":"<pre><code>media_type: str\n</code></pre> <p>The media type of the attachment, be it m.video, m.image, or m.audio.</p> <p>Returns:</p> Type Description <p><code>m.audio</code>, <code>m.image</code>, or <code>m.video</code></p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>Returns the size of the thumbnail in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.url","title":"url  <code>property</code>","text":"<pre><code>url: str | None\n</code></pre> <p>The current mxc URL of the attachment, if it has been uploaded.</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\nfile: pathlib.Path | str,\nthumbnail: Thumbnail = None,\ngen_blur_hash: bool = True,\n) -&gt; MediaAttachment\n</code></pre> <p>Creates a MediaAttachment from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>pathlib.Path | str</code> <p>The file to create the attachment from (Must be a path or pathlib.Path object, cannot be BytesIO)</p> required <code>thumbnail</code> <code>Thumbnail</code> <p>The thumbnail of the file, if applicable</p> <code>None</code> <code>gen_blur_hash</code> <code>bool</code> <p>Whether to generate a blurhash for the file</p> <code>True</code> <p>Returns:</p> Type Description <code>MediaAttachment</code> <p>A MediaAttachment object</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(client: NioBot, file_name: str = None)\n</code></pre> <p>Uploads the file to matrix.</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the attachment to a dictionary.</p>"},{"location":"reference/attachment/#niobot.attachment.FileAttachment","title":"FileAttachment","text":"<p>         Bases: <code>MediaAttachment</code></p> <p>Represents a generic file type, such as PDF or TXT.</p> <p>Do not use this class for images, audio or video.</p> <p>Do not use this class for images, audio or video. Use <code>MediaAttachment</code> instead. Furthermore, you should initialise this class manually - the <code>from_file</code> method does so much unnecessary work that it's not worth using for this attachment type.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to upload.</p> required <code>mime_type</code> <code>str</code> <p>The mime type of the file. If not specified, it will be detected automatically.</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.FileAttachment.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the attachment to a dictionary.</p>"},{"location":"reference/attachment/#niobot.attachment.detect_mime_type","title":"detect_mime_type","text":"<pre><code>detect_mime_type(\nfile: typing.Union[str, io.BytesIO, pathlib.Path]\n) -&gt; str\n</code></pre> <p>Detect the mime type of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to detect the mime type of. Can be a BytesIO.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The mime type of the file (e.g. <code>text/plain</code>, <code>image/png</code>, <code>application/pdf</code>, <code>video/webp</code> etc.)</p>"},{"location":"reference/attachment/#niobot.attachment.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(\nfile: typing.Union[str, pathlib.Path]\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>Gets metadata for a file via ffprobe.</p> Example result <pre><code>{\n\"streams\": [\n{\n\"index\": 0,\n\"codec_name\": \"h264\",\n\"codec_long_name\": \"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\",\n\"profile\": \"High\",\n\"codec_type\": \"video\",\n...\n}\n],\n\"format\": {\n\"filename\": \"./assets/peek.mp4\",\n\"format_long_name\": \"QuickTime / MOV\",\n\"start_time\": \"0.000000\",\n\"duration\": \"16.283333\",\n\"size\": \"4380760\",\n\"bit_rate\": \"2152266\",\n...\n}\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, pathlib.Path]</code> <p>The file to get metadata for. Must be a path-like object</p> required <p>Returns:</p> Type Description <code>typing.Dict[str, typing.Any]</code> <p>A dictionary containing the metadata.</p>"},{"location":"reference/attachment/#niobot.attachment.first_frame","title":"first_frame","text":"<pre><code>first_frame(\nfile: str | pathlib.Path, file_format: str = \"webp\"\n) -&gt; bytes\n</code></pre> <p>Gets the first frame of a video file.</p> <p>This function creates a file on disk</p> <p>In order to extract the frame, this function creates a temporary file on disk (or memdisk depending on where your tempdir is). While this file is deleted after the function is done, it is still something to be aware of. For example, if you're (worryingly) low on space, this function may fail to extract the frame due to a lack of space. Or, someone could temporarily access and read the file before it is deleted.</p> <p>This also means that this function may be slow.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | pathlib.Path</code> <p>The file to get the first frame of. Must be a path-like object</p> required <code>file_format</code> <code>str</code> <p>The format to save the frame as. Defaults to webp.</p> <code>'webp'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The first frame of the video in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.generate_blur_hash","title":"generate_blur_hash","text":"<pre><code>generate_blur_hash(file: str | pathlib.Path) -&gt; str\n</code></pre> <p>Creates a blurhash</p> <p>This function may be resource intensive</p> <p>This function may be resource intensive, especially for large images. You should run this in a thread or process pool.</p> <p>You should also scale any images down in order to increase performance.</p> <p>See: woltapp/blurhash</p>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#niobot.client.NioBot","title":"NioBot","text":"<p>         Bases: <code>nio.AsyncClient</code></p> <p>The main client for NioBot.</p> <p>Parameters:</p> Name Type Description Default <code>homeserver</code> <code>str</code> <p>The homeserver to connect to. e.g. https://matrix-client.matrix.org</p> required <code>user_id</code> <code>str</code> <p>The user ID to log in as. e.g. @user:matrix.org</p> required <code>device_id</code> <code>str</code> <p>The device ID to log in as. e.g. nio-bot</p> <code>'nio-bot'</code> <code>store_path</code> <code>str</code> <p>The path to the store file. Defaults to ./store. Must be a directory.</p> <code>None</code> <code>command_prefix</code> <code>str</code> <p>The prefix to use for commands. e.g. !</p> required <code>case_insensitive</code> <code>bool</code> <p>Whether to ignore case when checking for commands. If True, this lower()s incoming messages for parsing.</p> <code>True</code> <code>global_message_type</code> <code>str</code> <p>The message type to default to. Defaults to m.notice</p> <code>'m.notice'</code> <code>ignore_old_events</code> <code>bool</code> <p>Whether to simply discard events before the bot's login.</p> <code>True</code> <code>owner_id</code> <code>str</code> <p>The user ID of the bot owner. If set, only this user can run owner-only commands, etc.</p> <code>None</code>"},{"location":"reference/client/#niobot.client.NioBot.commands","title":"commands  <code>property</code>","text":"<pre><code>commands: typing.Dict[str, Command]\n</code></pre> <p>Returns the internal command register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p> <p>Note</p> <p>Aliases of commands are treated as their own command instance. You will see the same command show up as a value multiple times if it has aliases.</p>"},{"location":"reference/client/#niobot.client.NioBot.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: typing.Dict[typing.Type[Module], Module]\n</code></pre> <p>Returns the internal module register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p>"},{"location":"reference/client/#niobot.client.NioBot.latency","title":"latency  <code>staticmethod</code>","text":"<pre><code>latency(\nevent: nio.Event, *, received_at: float = None\n) -&gt; float\n</code></pre> <p>Returns the latency for a given event in milliseconds</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>nio.Event</code> <p>The event to measure latency with</p> required <code>received_at</code> <code>float</code> <p>The optional time the event was received at. If not given, uses the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The latency in milliseconds</p>"},{"location":"reference/client/#niobot.client.NioBot.dispatch","title":"dispatch","text":"<pre><code>dispatch(event_name: str, *args: str, **kwargs: str)\n</code></pre> <p>Dispatches an event to listeners</p>"},{"location":"reference/client/#niobot.client.NioBot.is_old","title":"is_old","text":"<pre><code>is_old(event: nio.Event) -&gt; bool\n</code></pre> <p>Checks if an event was sent before the bot started. Always returns False when ignore_old_evens is False</p>"},{"location":"reference/client/#niobot.client.NioBot.update_read_receipts","title":"update_read_receipts  <code>async</code>","text":"<pre><code>update_read_receipts(room, event)\n</code></pre> <p>part of spec module 11.6</p>"},{"location":"reference/client/#niobot.client.NioBot.process_message","title":"process_message  <code>async</code>","text":"<pre><code>process_message(\nroom: nio.MatrixRoom, event: nio.RoomMessageText\n)\n</code></pre> <p>Processes a message and runs the command it is trying to invoke if any.</p>"},{"location":"reference/client/#niobot.client.NioBot.is_owner","title":"is_owner","text":"<pre><code>is_owner(user_id: str) -&gt; bool\n</code></pre> <p>Checks whether a user is the owner of the bot.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The user ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user is the owner.</p>"},{"location":"reference/client/#niobot.client.NioBot.mount_module","title":"mount_module","text":"<pre><code>mount_module(\nimport_path: str,\n) -&gt; typing.Optional[list[Command]]\n</code></pre> <p>Mounts a module including all of its commands.</p> <p>Must be a subclass of niobot.commands.Module, or else this function will not work.</p> <p>Parameters:</p> Name Type Description Default <code>import_path</code> <code>str</code> <p>The import path (such as modules.file), which would be ./modules/file.py in a file tree.</p> required <p>Returns:</p> Type Description <code>typing.Optional[list[Command]]</code> <p>Optional[List[Command]] - A list of commands mounted. None if the module's setup() was called.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>The module path is incorrect of there was another error while importing</p> <code>TypeError</code> <p>The module was not a subclass of Module.</p> <code>ValueError</code> <p>There was an error registering a command (e.g. name conflict)</p>"},{"location":"reference/client/#niobot.client.NioBot.get_command","title":"get_command","text":"<pre><code>get_command(name: str) -&gt; Command | None\n</code></pre> <p>Attempts to retrieve an internal command</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command to retrieve</p> required <p>Returns:</p> Type Description <code>Command | None</code> <p>The command, if found. None otherwise.</p>"},{"location":"reference/client/#niobot.client.NioBot.add_command","title":"add_command","text":"<pre><code>add_command(command: Command) -&gt; None\n</code></pre> <p>Adds a command to the internal register</p> <p>if a name or alias is already registered, this throws a ValueError. Otherwise, it returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.remove_command","title":"remove_command","text":"<pre><code>remove_command(command: Command) -&gt; None\n</code></pre> <p>Removes a command from the internal register.</p> <p>If the command is not registered, this is a no-op.</p>"},{"location":"reference/client/#niobot.client.NioBot.command","title":"command","text":"<pre><code>command(name: str = None, **kwargs: str)\n</code></pre> <p>Registers a command with the bot.</p>"},{"location":"reference/client/#niobot.client.NioBot.on_event","title":"on_event","text":"<pre><code>on_event(event_type: str = None)\n</code></pre> <p>Wrapper that allows you to register an event handler</p>"},{"location":"reference/client/#niobot.client.NioBot.room_send","title":"room_send  <code>async</code>","text":"<pre><code>room_send(\nroom_id: str,\nmessage_type: str,\ncontent: dict,\ntx_id: str | None = None,\nignore_unverified_devices: bool = True,\n) -&gt; nio.RoomSendResponse | nio.RoomSendError\n</code></pre> <p>Send a message to a room. Wrapper. See :meth:<code>nio.AsyncClient.room_send</code> for more information.</p>"},{"location":"reference/client/#niobot.client.NioBot.get_cached_message","title":"get_cached_message","text":"<pre><code>get_cached_message(\nevent_id: str,\n) -&gt; typing.Optional[\ntyping.Tuple[nio.MatrixRoom, nio.RoomMessageText]\n]\n</code></pre> <p>Fetches a message from the cache.</p> <p>This returns both the room the message was sent in, and the event itself.</p> <p>If the message is not in the cache, this returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.fetch_message","title":"fetch_message  <code>async</code>","text":"<pre><code>fetch_message(room_id: str, event_id: str)\n</code></pre> <p>Fetches a message from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.wait_for_message","title":"wait_for_message  <code>async</code>","text":"<pre><code>wait_for_message(\nroom_id: str = None,\nsender: str = None,\ncheck: typing.Callable[\n[nio.MatrixRoom, nio.RoomMessageText], typing.Any\n] = None,\n*,\ntimeout: float = None\n) -&gt; typing.Optional[\ntyping.Tuple[nio.MatrixRoom, nio.RoomMessageText]\n]\n</code></pre> <p>Waits for a message, optionally with a filter.</p> <p>If this function times out, asyncio.TimeoutError is raised.</p>"},{"location":"reference/client/#niobot.client.NioBot.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(\nroom: nio.MatrixRoom | str,\ncontent: str = None,\nfile: MediaAttachment = None,\nreply_to: nio.RoomMessageText | str = None,\nmessage_type: str = None,\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Sends a message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room to send this message to</p> required <code>content</code> <code>str</code> <p>The content to send. Cannot be used with file.</p> <code>None</code> <code>file</code> <code>MediaAttachment</code> <p>A file to send, if any. Cannot be used with content.</p> <code>None</code> <code>reply_to</code> <code>nio.RoomMessageText | str</code> <p>A message to reply to.</p> <code>None</code> <code>message_type</code> <code>str</code> <p>The message type to send. If none, defaults to NioBot.global_message_type, which itself is <code>m.notice</code> by default.</p> <code>None</code> <p>Returns:</p> Type Description <code>nio.RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to send, or if the file fails to upload.</p> <code>ValueError</code> <p>You specified neither file nor content.</p>"},{"location":"reference/client/#niobot.client.NioBot.edit_message","title":"edit_message  <code>async</code>","text":"<pre><code>edit_message(\nroom: nio.MatrixRoom | str,\nevent_id: nio.Event | str,\ncontent: str,\n*,\nmessage_type: str = None\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Edit an existing message. You must be the sender of the message.</p> <p>You also cannot edit messages that are attachments.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>event_id</code> <code>nio.Event | str</code> <p>The message to edit.</p> required <code>content</code> <code>str</code> <p>The new content of the message.</p> required <code>message_type</code> <code>str</code> <p>The new type of the message (i.e. m.text, m.notice. Defaults to client.global_message_type)</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>TypeError</code> <p>If the message is not text.</p>"},{"location":"reference/client/#niobot.client.NioBot.delete_message","title":"delete_message  <code>async</code>","text":"<pre><code>delete_message(\nroom: nio.MatrixRoom | str,\nmessage_id: nio.RoomMessage | str,\nreason: str = None,\n) -&gt; nio.RoomRedactResponse\n</code></pre> <p>Delete an existing message. You must be the sender of the message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>message_id</code> <code>nio.RoomMessage | str</code> <p>The message to delete.</p> required <code>reason</code> <code>str</code> <p>The reason for deleting the message.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p>"},{"location":"reference/client/#niobot.client.NioBot.start","title":"start  <code>async</code>","text":"<pre><code>start(\npassword: str = None,\naccess_token: str = None,\nsso_token: str = None,\n) -&gt; None\n</code></pre> <p>Starts the bot, running the sync loop.</p>"},{"location":"reference/client/#niobot.client.NioBot.run","title":"run","text":"<pre><code>run(\n*,\npassword: str = None,\naccess_token: str = None,\nsso_token: str = None\n) -&gt; None\n</code></pre> <p>Runs the bot, blocking the program until the event loop exists. This should be the last function to be called in your script, as once it exits, the bot will stop running.</p> <p>Note:     This function is literally just asyncio.run(NioBot.start(...)), so you won't have much control over the     asyncio event loop. If you want more control, you should use await NioBot.start(...) instead.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to log in with.</p> <code>None</code> <code>access_token</code> <code>str</code> <p>An existing login token.</p> <code>None</code> <code>sso_token</code> <code>str</code> <p>An SSO token to sign in with.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/commands/","title":"Commands","text":"<p>Using commands and events is the main way to interact with the bot.</p>"},{"location":"reference/commands/#niobot.commands.Argument","title":"Argument","text":"<p>Represents a command argument.</p> Example <pre><code>from niobot import NioBot, command, Argument\nbot = NioBot(...)\n@bot.command(\"echo\", arguments=[Argument(\"message\", str)])\ndef echo(ctx: niobot.Context, message: str):\nawait ctx.respond(message)\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument. Will be used to know which argument to pass to the command callback.</p> required <code>arg_type</code> <code>_T</code> <p>The type of the argument (e.g. str, int, etc. or a custom type)</p> required <code>description</code> <code>str</code> <p>The description of the argument. Will be shown in the auto-generated help command.</p> <code>None</code> <code>default</code> <code>typing.Any</code> <p>The default value of the argument</p> <code>Ellipsis</code> <code>required</code> <code>bool</code> <p>Whether the argument is required or not. Defaults to True if default is ..., False otherwise.</p> <code>Ellipsis</code>"},{"location":"reference/commands/#niobot.commands.Argument.internal_parser","title":"internal_parser  <code>staticmethod</code>","text":"<pre><code>internal_parser(\n_: Context, arg: Argument, value: str\n) -&gt; typing.Optional[_T]\n</code></pre> <p>The default parser for the argument. Will try to convert the value to the argument type.</p>"},{"location":"reference/commands/#niobot.commands.Command","title":"Command","text":"<p>Represents a command.</p> Example <p>Note</p> <p>This example uses the <code>command</code> decorator, but you can also use the <code>Command</code> class directly, but you likely won't need to, unless you want to pass a custom command class.</p> <p>All that the <code>@command</code> decorator does is create a <code>Command</code> instance and add it to the bot's commands, while wrapping the function its decorating.</p> <pre><code>from niobot import NioBot, command\nbot = NioBot(...)\n@bot.command(\"hello\")\ndef hello(ctx: niobot.Context):\nawait ctx.respond(\"Hello, %s!\" % ctx.message.sender)\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Will be used to invoke the command.</p> required <code>callback</code> <code>callable</code> <p>The callback to call when the command is invoked.</p> required <code>aliases</code> <code>list[str]</code> <p>The aliases of the command. Will also be used to invoke the command.</p> <code>None</code> <code>description</code> <code>str</code> <p>The description of the command. Will be shown in the auto-generated help command.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the command is disabled or not. If disabled, the command will be hidden on the auto-generated help command, and will not be able to be invoked.</p> <code>False</code> <code>arguments</code> <p>A list of <code>Argument</code> instances. Will be used to parse the arguments given to the command. <code>ctx</code> is always the first argument, regardless of what you put here.</p> required <code>usage</code> <p>A string representing how to use this command's arguments. Will be shown in the auto-generated help. Do not include the command name or your bot's prefix here, only arguments.</p> required"},{"location":"reference/commands/#niobot.commands.Command.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if another command's runtime ID is the same as this one's</p>"},{"location":"reference/commands/#niobot.commands.Command.invoke","title":"invoke","text":"<pre><code>invoke(ctx: Context)\n</code></pre> <p>Invokes the current command with the given context</p>"},{"location":"reference/commands/#niobot.commands.Module","title":"Module","text":""},{"location":"reference/commands/#niobot.commands.Module.__setup__","title":"__setup__","text":"<pre><code>__setup__()\n</code></pre> <p>Setup function called once by NioBot.mount_module(). Mounts every command discovered.</p>"},{"location":"reference/commands/#niobot.commands.Module.__teardown__","title":"__teardown__","text":"<pre><code>__teardown__()\n</code></pre> <p>Teardown function called once by NioBot.unmount_module(). Removes any command that was mounted.</p>"},{"location":"reference/commands/#niobot.commands.command","title":"command","text":"<pre><code>command(name: str = None, **kwargs: str) -&gt; callable\n</code></pre> <p>Allows you to register commands later on, by loading modules.</p> <p>This differs from NioBot.command() in that commands are not automatically added, you need to load them with bot.mount_module</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Defaults to function.name</p> <code>None</code> <code>kwargs</code> <p>Any key-words to pass to Command</p> <code>{}</code> <p>Returns:</p> Type Description <code>callable</code>"},{"location":"reference/commands/#niobot.commands.event","title":"event","text":"<pre><code>event(name: str) -&gt; callable\n</code></pre> <p>Allows you to register event listeners in modules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the event (no <code>on_</code> prefix)</p> required <p>Returns:</p> Type Description <code>callable</code>"},{"location":"reference/context/","title":"Context","text":"<p>For each command invoked, the first argument is always a <code>Context</code> instance, which holds a lot of metadata, and a few utility functions to help you write commands.</p> <p>A lot of the time, these are the three main attributes you'll be using:</p> <ul> <li><code>Context.room</code> (<code>nio.MatrixRoom</code>) - the room the command was invoked in.</li> <li><code>Context.event</code> (<code>nio.RoomMessageText</code>) - the message that invoked this command.</li> <li><code>Context.respond</code> - a utility class to help you respond to the command.</li> </ul>"},{"location":"reference/context/#command-context","title":"Command Context","text":"<p>Event-based context for a command callback</p>"},{"location":"reference/context/#niobot.context.Context.room","title":"room  <code>property</code>","text":"<pre><code>room: nio.MatrixRoom\n</code></pre> <p>The room that the event was dispatched in</p>"},{"location":"reference/context/#niobot.context.Context.client","title":"client  <code>property</code>","text":"<pre><code>client: NioBot\n</code></pre> <p>The current instance of the client</p>"},{"location":"reference/context/#niobot.context.Context.command","title":"command  <code>property</code>","text":"<pre><code>command: Command\n</code></pre> <p>The current command being invoked</p>"},{"location":"reference/context/#niobot.context.Context.args","title":"args  <code>property</code>","text":"<pre><code>args: list[str]\n</code></pre> <p>Each argument given to this command</p>"},{"location":"reference/context/#niobot.context.Context.message","title":"message  <code>property</code>","text":"<pre><code>message: nio.RoomMessageText\n</code></pre> <p>The current message</p>"},{"location":"reference/context/#niobot.context.Context.original_response","title":"original_response  <code>property</code>","text":"<pre><code>original_response: typing.Optional[nio.RoomSendResponse]\n</code></pre> <p>The result of Context.reply(), if it exists.</p>"},{"location":"reference/context/#niobot.context.Context.latency","title":"latency  <code>property</code>","text":"<pre><code>latency: float\n</code></pre> <p>Returns the current event's latency in milliseconds.</p>"},{"location":"reference/context/#niobot.context.Context.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(\ncontent: str = None, file: MediaAttachment = None\n) -&gt; ContextualResponse\n</code></pre> <p>Responds to the current event.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text to reply with</p> <code>None</code> <code>file</code> <code>MediaAttachment</code> <p>A file to reply with</p> <code>None</code> <p>Returns:</p> Type Description <code>ContextualResponse</code>"},{"location":"reference/context/#contextual-response","title":"Contextual Response","text":"<p>Context class for managing replies.</p> <p>Usage of this function is not required, however it is a useful utility.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.message","title":"message  <code>property</code>","text":"<pre><code>message: nio.RoomMessageText | None\n</code></pre> <p>Fetches the current message for this response</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.reply","title":"reply  <code>async</code>","text":"<pre><code>reply(*args) -&gt; ContextualResponse\n</code></pre> <p>Replies to the current response.</p> <p>This does NOT reply to the original invoking message.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>args to pass to send_message</p> <code>()</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>a new ContextualResponse object.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(content: str, **kwargs: str) -&gt; ContextualResponse\n</code></pre> <p>Edits the current response.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The new content to edit with</p> required <code>kwargs</code> <p>Any extra arguments to pass to Client.edit_message</p> <code>{}</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>self</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(reason: str = None) -&gt; None\n</code></pre> <p>Redacts the current response.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>An optional reason for the redaction</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None, as there will be no more response.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#niobot.exceptions.NioBotException","title":"NioBotException","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for NioBot.</p> <p>Warning</p> <p>In some rare cases, all of <code>exception</code>, <code>response</code> and <code>original</code> may be None.</p> <p>All other exceptions raised by this library will subclass this exception, so at least all the below are always available:</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str | None</code> <p>A simple humanised explanation of the issue, if available.</p> <code>response</code> <code>nio.ErrorResponse | None</code> <p>The response object from the server, if available.</p> <code>exception</code> <code>typing.Union[nio.ErrorResponse, Exception]</code> <p>The exception that was raised, if available.</p> <code>original</code> <code>nio.ErrorResponse | Exception | None</code> <p>The original response, or exception if response was not available.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a human-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Returns a developer-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MessageException","title":"MessageException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for message-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.LoginException","title":"LoginException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for login-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaUploadException","title":"MediaUploadException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for media-uploading related errors</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandError","title":"CommandError","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception subclass for all command invocation related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandDisabledError","title":"CommandDisabledError","text":"<p>         Bases: <code>CommandError</code></p> <p>Exception raised when a command is disabled.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandArgumentsError","title":"CommandArgumentsError","text":"<p>         Bases: <code>CommandError</code></p> <p>Exception subclass for command argument related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandParserError","title":"CommandParserError","text":"<p>         Bases: <code>CommandArgumentsError</code></p> <p>Exception raised when there is an error parsing arguments.</p>"},{"location":"reference/utils/federation/","title":"Federation","text":"<p>There isn't a lot here aside from a homeserver resolver. A lot of the federation is already handled by matrix-nio itself, so there isn't a lot of need for federation-specific utilities.</p>"},{"location":"reference/utils/federation/#niobot.utils.federation.resolve_homeserver","title":"resolve_homeserver  <code>async</code>","text":"<pre><code>resolve_homeserver(domain: str) -&gt; str\n</code></pre> <p>Resolves a given homeserver part to the actual homeserver</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain to crawl</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resolved homeserver</p>"},{"location":"reference/utils/help_command/","title":"The help command","text":"<p><code>NioBot</code> comes with a built-in help command, which can be used to display information about other commands.</p> <p>This built-in command is simple, slick, and most importantly, helpful. It takes one optional argument, <code>command</code>, which changes the output to display information about a specific command. Without this, the help command will list every enabled command, their aliases, a short help string, and a short description about the command (by default, the first line of the docstring).</p> <p>This allows for you to easily just add commands and not have to worry about documenting them outside of simply defining their usage in the command decorator, and a short description in the docstring.</p> An example of the help command with no arguments Source of this sample <p>This is the output of the help command from  EEKIM10/niobot-test</p> <pre><code>?[help|h]: Shows a list of commands for this bot\n?[ytdl|yt|dl|yl-dl|yt-dlp] &lt;url&gt; [format]: Downloads a video from YouTube\n?[quote|q]: Generate a random quote.\n?ping: Shows the roundtrip latency\n?info: Shows information about the bot\n?cud: Creates, updates, and deletes a message\n?upload &lt;type: image|video|audio|file&gt;: Uploads an image\n?hello: Asks for an input\n?version: Shows the version of nio\n?[pretty-print|pp]: Pretty prints given JSON\n?eval: Evaluates Python code\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p> An example of the help command with a specified command name Source of this sample <p>This is the output of the help command from  EEKIM10/niobot-test</p> <pre><code>?[help|h]:\nShows a list of commands for this bot\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p>"},{"location":"reference/utils/help_command/#registering-your-own-help-command","title":"Registering your own help command","text":"<p>If you would like to register your own help command, you need to be aware of the following:</p> <ul> <li>The help command is a command, much like any other command, and is registered as such. You should be aware of  aliases, case sensitivity, command states (e.g. disabled/enabled), etc.</li> <li>A help command is almost always a user's first impression of your bot. You should make sure that it works 100% of the time, is insanely simple to use, and is very helpful. A help command that just says \"You can use command like ?info\" is not helpful at all, and will likely turn many users away.</li> </ul> <p>???+ question Are there any dangers to these help commands?</p>"},{"location":"reference/utils/help_command/#help-command-functions","title":"Help Command functions:","text":""},{"location":"reference/utils/help_command/#niobot.utils.help_command.clean_output","title":"clean_output","text":"<pre><code>clean_output(\ntext: str,\n*,\nescape_user_mentions: bool = True,\nescape_room_mentions: bool = True,\nescape_room_references: bool = False,\nescape_all_periods: bool = False,\nescape_all_at_signs: bool = False,\nescape_method: typing.Callable[[str], str] = None\n) -&gt; str\n</code></pre> <p>Escapes given text and sanitises it, ready for outputting to the user.</p> <p>This should always be used when echoing any sort of user-provided content, as we all know there will be some annoying troll who will just go <code>@room</code> for no apparent reason every 30 seconds.</p> <p>Do not rely on this!</p> <p>This function is not guaranteed to escape all possible mentions, and should not be relied upon to do so. It is only meant to be used as a convenience function for simple commands.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to sanitise</p> required <code>escape_user_mentions</code> <code>bool</code> <p>Escape all @user:homeserver.tld mentions</p> <code>True</code> <code>escape_room_mentions</code> <code>bool</code> <p>Escape all @room mentions</p> <code>True</code> <code>escape_room_references</code> <code>bool</code> <p>Escape all #room:homeserver.tld references</p> <code>False</code> <code>escape_all_periods</code> <code>bool</code> <p>Escape all literal <code>.</code> characters (can be used to escape all links)</p> <code>False</code> <code>escape_all_at_signs</code> <code>bool</code> <p>Escape all literal <code>@</code> characters (can be used to escape all mentions)</p> <code>False</code> <code>escape_method</code> <code>typing.Callable[[str], str]</code> <p>A custom escape method to use instead of the built-in one (which just wraps characters in <code>\\u200b</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The cleaned text</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.format_command_name","title":"format_command_name","text":"<pre><code>format_command_name(command: Command) -&gt; str\n</code></pre> <p>Formats the command name with its aliases if applicable</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.format_command_line","title":"format_command_line","text":"<pre><code>format_command_line(prefix: str, command: Command) -&gt; str\n</code></pre> <p>Formats a command line, including name(s) &amp; usage.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.get_short_description","title":"get_short_description","text":"<pre><code>get_short_description(command: Command) -&gt; str\n</code></pre> <p>Generates a short (&lt;100 characters) help description for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.get_long_description","title":"get_long_description","text":"<pre><code>get_long_description(command: Command) -&gt; str\n</code></pre> <p>Gets the full help text for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.help_command_callback","title":"help_command_callback  <code>async</code>","text":"<pre><code>help_command_callback(ctx: Context)\n</code></pre> <p>Displays help text</p>"},{"location":"reference/utils/parsers/","title":"Parsers","text":"<p>These are a handful of built-in parsers that you can use with <code>niobot.Argument</code>.</p> How do I use these? <p>To use a parser, you simply pass <code>parser=&lt;function&gt;</code> when creating <code>Argument()</code>. For example:</p> <pre><code>from niobot import Argument, command, NioBot\nfrom niobot.utils.parsers import float_parser\nbot = NioBot(...)\n@bot.command(\nname=\"sum\", \narguments=[\nArgument(\"num1\", parser=float_parser),\nArgument(\"num2\", parser=float_parser)\n]\n)\nasync def add_numbers(ctx: Context, num1: float, num2: float):\nawait ctx.respond(\"{!s} + {!s} = {!s}\".format(num1, num2, num1 + num2))\nbot.run(...)\n</code></pre> <p>While this is roughly equivalent to <code>Argument(\"num1\", type=float)</code>, it can be helpful in cases like  json_parser where you need to parse complex types.</p> <p>Tip</p> <p>You can also create your own parsers! See Creating Parsers for more information.</p> <p>This utility modules contains a handful of simple off-the-shelf parser for some basic python types.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.boolean_parser","title":"boolean_parser","text":"<pre><code>boolean_parser(_: Context, __: Context, value: str) -&gt; bool\n</code></pre> <p>Converts a given string into a boolean. Value is lower-cased before being parsed.</p> <p>The following resolves to true:     1, y, yes, true, on</p> <p>The following resolves to false:     0, n, no, false, off</p> <p>The following will raise a command argument error: anything else</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The parsed boolean</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.float_parser","title":"float_parser","text":"<pre><code>float_parser(_: Context, __: Argument, value: str) -&gt; float\n</code></pre> <p>Converts a given string into a floating point number.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <code>Argument</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>float</code> <p>A parsed boolean</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.integer_parser","title":"integer_parser","text":"<pre><code>integer_parser(\nallow_floats: bool = False, base: int = 10\n) -&gt; typing.Callable[\n[Context, Argument, str], typing.Union[int, float]\n]\n</code></pre> <p>Converts a given value into an integer, or a float if allowed.</p> <p>Parameters:</p> Name Type Description Default <code>allow_floats</code> <code>bool</code> <p>Whether to allow parsing for floating numbers (decimals). Defaults to False.</p> <code>False</code> <code>base</code> <code>int</code> <p>The base to parse (defaults to base 10, denary)</p> <code>10</code> <p>Returns:</p> Type Description <code>typing.Callable[[Context, Argument, str], typing.Union[int, float]]</code> <p>The parsed number.</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.json_parser","title":"json_parser","text":"<pre><code>json_parser(\n_: Context, __: Argument, value: str\n) -&gt; typing.Union[\nlist, dict, str, int, float, type(None), bool\n]\n</code></pre> <p>Converts a given string into a JSON object.</p> <p>.. Note::     If you want this to be fast, you should install orjson. It is a drop-in replacement for the standard library.     While the parser will still work without it, it may be slower, especially for larger payloads.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <code>Argument</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>typing.Union[list, dict, str, int, float, type(None), bool]</code> <p>The parsed JSON object</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid JSON object.</p>"},{"location":"reference/utils/parsers/#creating-parsers","title":"Creating Parsers","text":"<p>Creating your own parser is actually really easy. All the library needs from you is a function that:</p> <ul> <li>Takes <code>niobot.Context</code> as its first argument</li> <li>Takes <code>niobot.Argument</code> as its second argument</li> <li>Takes a <code>str</code>ing (the user's input) as its third argument</li> <li>Returns a sensible value</li> <li>Or, raises CommandArgumentsError with a helpful error message.</li> </ul> <p>Do all of this, and you can very easily just pass this to <code>Argument</code>!</p> <p>For example, if you wanted to take a <code>datetime</code>, you could write your own parser like this:</p> <pre><code>from datetime import datetime\nfrom niobot import Argument, command, NioBot\ndef datetime_parser(ctx: Context, arg: Argument, user_input: str):\ntry:\nreturn datetime.strptime(user_input, \"%Y-%m-%d %H:%M:%S\")\nexcept ValueError:\nraise CommandArgumentsError(\"Invalid datetime format. Expected YYYY-MM-DD HH:MM:SS\")\nbot = NioBot(...)\n@bot.command(name=\"remindme\", arguments=[Argument(\"time\", arg_type=datetime, parser=datetime_parser)])\nasync def remind_me(ctx: Context, time: datetime):\nawait ctx.respond(\"I'll remind you at {}!\".format(time.strftime(\"%c\")))\nbot.run(...)\n</code></pre>"},{"location":"reference/utils/string_view/","title":"String View","text":"<p>This is mostly an internal utility.</p> <p>The ArgumentView is mostly used by the internal command parser to parse arguments. While you will be able to use this yourself, its very unlikely that you'll ever actually need it.</p> <p>This is a work in progress.</p> <p>The string view does a lot of complicated maths and logic to determine arguments. It's not as simple as just splitting the string on every whitespace and calling it an argument, the ArgumentView parser has to check for quotes, escape characters, and more.</p> <p>Due to the complexity of the parser, it's very likely that there are still bugs in the parser. Fixes welcome!</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView","title":"ArgumentView","text":"<p>A parser designed to allow for multi-word arguments and quotes</p> <p>For example, the arguments <code>1 \"2 3\" 4</code> would result in three items in the internal list: <code>1</code>, <code>2 3</code>, and <code>4</code></p> <p>This is most useful when parsing arguments from a command, as it allows for multi-word arguments.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse</p> required"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.eof","title":"eof  <code>property</code>","text":"<pre><code>eof: bool\n</code></pre> <p>Returns whether the parser has reached the end of the string</p> <p>Returns:</p> Type Description <p>Whether the parser has reached the end of the string (cursor is greater than or equal to the length of the string)</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.add_arg","title":"add_arg","text":"<pre><code>add_arg(argument: str) -&gt; None\n</code></pre> <p>Adds an argument to the argument list</p> <p>Parameters:</p> Name Type Description Default <code>argument</code> <code>str</code> <p>The argument to add</p> required <p>Returns:</p> Type Description <code>None</code> <p>none</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.parse_arguments","title":"parse_arguments","text":"<pre><code>parse_arguments() -&gt; ArgumentView\n</code></pre> <p>Main parsing engine.</p> <p>Returns:</p> Type Description <code>ArgumentView</code> <p>self</p>"},{"location":"reference/utils/typing/","title":"Typing helper","text":"<p>This utility module contains one tool: the <code>Typing</code> class. It is internally used in the <code>&lt;send/edit/delete&gt;_message</code> functions of <code>NioBot</code>, but you can use it at any point to send typing events to the chat.</p>"},{"location":"reference/utils/typing/#usage","title":"Usage","text":"<p>Context manager to manage typing notifications.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The <code>NioBot</code> instance</p> required <code>room_id</code> <code>str</code> <p>The room id to send the typing notification to</p> required <code>timeout</code> <code>int</code> <p>The timeout in seconds</p> <code>30</code> <code>persistent</code> <code>bool</code> <p>Whether to send a typing notification every <code>timeout</code> seconds, to keep the typing status active</p> <code>True</code> <p>Warning</p> <p>Nesting <code>Typing</code> instances for one specific room is a bad idea, as when each instance is exited, it stops typing for the given room. For example, the below will not work as expected:</p> <pre><code>from niobot import NioBot, utils\nbot = NioBot(...)\n@bot.command()\nasync def ping(ctx):\nasync with utils.Typing(ctx.client, ctx.room.room_id):\nawait ctx.respond(\"Pong!\")\nbot.run(...)\n</code></pre> <p>This will not work because <code>Context.respond</code> calls <code>NioBot.send_message</code>, and <code>NioBot.send_message</code> creates its own <code>Typing</code> instance. Once <code>ctx.respond</code> returns, the internal <code>Typing</code> instance is destroyed, and the typing event is stopped, as is the behaviour of exiting the context manager. This means that either if on the loop, the upper-most <code>utils.Typing</code> instance will simply just create a new typing notification, or will not (especially if <code>persistent</code> was set to <code>False</code>). This breaks the whole persistence of typing.</p> If you want to use <code>Typing</code> to show that you're processing something: <p>If you want to use <code>Typing</code> to show a user that your bot is \"thinking\", or similar, you should make sure you exit the instance before responding. For example:</p> <pre><code>from niobot import NioBot, Typing\nimport httpx\nbot = NioBot(...)\n@bot.command()\nasync def process(ctx):\n\"\"\"Spends a worryingly long time making a network request.\"\"\"\nasync with Typing(ctx.client, ctx.room.room_id):\nawait httpx.get(\"https://example.com\")\nawait ctx.respond(\"Done!\")\n</code></pre> <p>Be aware that this will cause a momentary blip in the <code>xyz is typing</code> status, but this is unavoidable, simply due to the semi-stateless nature of this context wrapper</p> <p>A potential future solution would be to implement some funky internal lock mechanism and/or just prevent nested <code>Typing</code> instances, but this is not a priority at the moment.</p>"},{"location":"reference/utils/typing/#niobot.utils.typing.Typing.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Starts the typing notification loop, or sends a single typing notification if not persistent.</p>"},{"location":"reference/utils/typing/#niobot.utils.typing.Typing.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc, tb)\n</code></pre> <p>Cancels any existing typing loop under this instance and sends a typing notification to stop typing.</p>"},{"location":"reference/utils/unblock/","title":"Unblock","text":"<p>A common problem developers encounter when working with an asyncio event loop is long blocking code. This can be caused by a number of things, but the most common is a call to a library that is not async-aware, and has many blocking operations (such as <code>requests</code>, or even the built-in <code>open()</code> + <code>read()</code> functions).</p> <p>To alleviate this, NioBot provides an \"unblock\" utility, which is a simple async function that will run any blocking code in the event loop executor, and returns the result, without pausing the event loop. This is equivalent to <code>loop.run_in_executor(None, func, *args, **kwargs)</code>.</p> A good example <p><pre><code>from niobot import NioBot, command\nfrom niobot.utils import run_blocking\nbot = NioBot(...)\n@bot.command(name=\"read\")\nasync def read_file(ctx: Context, filename: str):\nwith open(filename, \"r\") as f:\ncontents = await run_blocking(f.read)\nawait ctx.respond(contents)\nbot.run(...)\n</code></pre> This will read the contents of a file, without blocking the event loop, unlike the following code:</p> A bad example <p><pre><code>    from niobot import NioBot, command\nfrom niobot.utils import run_blocking\nbot = NioBot(...)\n@bot.command(name=\"read\")\nasync def read_file(ctx: Context, filename: str):\nwith open(filename, \"r\") as f:\ncontents = f.read()\nawait ctx.respond(contents)\nbot.run(...)\n</code></pre> This example is bad because it will prevent any other event processing until <code>f.read()</code> finishes, which is really bad if the file is large, or the disk is slow. For example, if you read at 1mb/s, and you have a 10 megabyte file, you will block the event loop for approximately 10 seconds, which means your program cannot do anything in those ten seconds, and as such your bot will appear to be non-functional!</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.run_blocking","title":"run_blocking  <code>async</code>","text":"<pre><code>run_blocking(\nfunction: typing.Callable, *args: Any, **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Takes a blocking function and runs it in a thread, returning the result.</p> <p>You should use this for any long-running functions that may take a long time to respond that are not coroutines that you can await. For example, running a subprocess.</p> Example <pre><code>import asyncio\nimport subprocess\nfrom niobot.utils import run_blocking\nasync def main():\nresult = await run_blocking(subprocess.run, [\"find\", \"*.py\", \"-type\", \"f\"], capture_output=True)\nprint(result)\nasyncio.run(main())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>typing.Callable</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function.</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.force_await","title":"force_await  <code>async</code>","text":"<pre><code>force_await(\nfunction: typing.Union[\ntyping.Callable, typing.Coroutine\n],\n*args: Any,\n**kwargs: Any\n)\n</code></pre> <p>Takes a function, and if it needs awaiting, it will be awaited. If it is a synchronous function, it runs it in the event loop, preventing it from blocking.</p> <p>This is equivalent to (pseudo): <pre><code>if can_await(x):\nawait x\nelse:\nawait run_blocking(x)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>typing.Union[typing.Callable, typing.Coroutine]</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the function.</p>"}]}