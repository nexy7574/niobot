{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#welcome-to-the-nio-bot-documentation","title":"Welcome to the Nio-Bot Documentation","text":"<p>Warning</p> <p>This documentation is still a work in progress, and is auto-generated from docstrings. If you notice any errors, please open a new issue.</p> <p>Furthermore, the docs are still partially written in sphinx (RST) format. Broken links are to be expected.</p>"},{"location":"#installing","title":"Installing","text":"<p>As this package is not yet on PyPi, you must install from git:</p>"},{"location":"#via-pip","title":"Via pip:","text":"<pre><code>$ pip install git+https://github.com/EEKIM10/niobot.git\n</code></pre>"},{"location":"#in-requirementstxt","title":"In requirements.txt:","text":"<pre><code>niobot[e2ee,cli] @ git+https://github.com/EEKIM10/niobot.giit\n</code></pre>"},{"location":"#cli","title":"CLI","text":"<p>The <code>niobot</code> package comes with a CLI tool, which can be used to create templates, get access tokens, resolve homeservers, and more (in the future).</p> <p>You can install the cli tool with the <code>cli</code> extra. The command itself is <code>niocli</code>.</p>"},{"location":"#version-information","title":"Version information","text":"<p>Version information is found in the <code>__version__.py</code> file, which is created while installing the package.</p> <pre><code>from niobot.__version__ import __version__\nprint(__version__)\n</code></pre>"},{"location":"#logging","title":"Logging","text":"<p>Logging is done using the <code>logging</code> module. The logger is named <code>niobot.&lt;module&gt;</code>. For example:</p> <p><pre><code>import logging\nimport niobot\nlogging.basicConfig(level=logging.INFO)\nbot = niobot.NioBot(...)\nbot.run(...)\n</code></pre> This will now output a bunch of logs to your console, which you can use to debug your bot.</p>"},{"location":"guides/getting-started/","title":"Getting started / quick start","text":"<p>Unfinished guide</p> <p>This guide is not yet finished.</p> <p>So, you've joined matrix, had a look around, and now you want to make your own little bot? Guess what, you can do just that with nio-bot!</p>"},{"location":"guides/getting-started/#prerequisites","title":"Prerequisites","text":"<p>You will need the following in general:</p> <ul> <li>A matrix account you can log into (username and password initially)</li> </ul> <p>And the following installed on the machine you want to run the bot on:</p> <ul> <li>Python 3.11 or higher with sqlite support</li> <li><code>libolm</code> (use your system package manager, like apt or pacman) in order to use end-to-end encryption.</li> <li>A decent network connection (at least a few megabits a second, preferably more)</li> <li>At least 100mb free storage space (for the database and other files)</li> </ul>"},{"location":"guides/getting-started/#installation","title":"Installation","text":"<p>After you've installed and acquired the above, you can install nio-bot with the following command: <pre><code>python3 -m pip install git+https://github.com/EEKIM10/nio-bot.git#egg=nio-bot[cli]\n# Note that we install the extras for `cli` here - the niobot CLI comes with a bunch of useful tools we'll use.\n</code></pre> If you would like to install support for end-to-end encryption, you can install the following instead: <pre><code>python3 -m pip install git+https://github.com/EEKIM10/nio-bot.git#egg=nio-bot[cli,e2ee]\n</code></pre></p> <p>After you've done that, verify everything installed fine by running <code>niocli version</code>: <pre><code>(venv) [me@host test-niobot]$ niocli version\nNioBot version: 0.1.dev115+g5af233e (Version 0.1, build dev115, commit '5af233e', built '04/07/230')\nmatrix-nio version: 0.20.2\nPython version: 3.11.3\nPython implementation: CPython\nOperating System: Linux-6.4.1-arch1-1-x86_64-with-glibc2.37\nArchitecture: x86_64\nOLM Installed: Yes\n</code></pre></p> <p>Info</p> <p>Yes, this output is long and verbose. It is intentionally long and verbose in order to provide as much information as possible for bug reports. All you need to do is make sure there aren't too many red flags.</p> <p>For example, if you want end to end encryption, but <code>OLM Installed</code> is a red <code>No</code>, then you need to install <code>libolm</code>.</p> My architecture is red! <p>You will notice any sort of other architecture outside of <code>x86_64</code> is red - this does not mean that nio-bot won't work! Currently, nio-bot is mainly developed on an AMD64 architecture, so support is only officially for that arch. However, several people have run nio-bot on ARM64 (raspberry pi, at least), and it works fine.</p> <p>You can safely ignore this warning if you are running on a different architecture.</p> <p>If anything else is red though, you should look into it.</p>"},{"location":"guides/getting-started/#creating-the-start-of-your-bot","title":"Creating the start of your bot","text":"<p>In our instance here, we'll create a few files:</p> <ol> <li>A <code>config.py</code> file to store our configuration.</li> <li>A <code>main.py</code> file to store our bot code.</li> <li>A <code>fun.py</code> file to store a module (later on).</li> </ol> <p>And you'll need a directory:</p> <ol> <li><code>store</code> - this is where nio-bot will store its database and other files.</li> </ol>"},{"location":"guides/getting-started/#file-structure","title":"File structure","text":"<p>And as such, our directory structure will look like this: <pre><code>test-niobot/\n\u251c\u2500\u2500 config.py\n\u251c\u2500\u2500 fun.py\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 store/\n\u2514\u2500\u2500 main.py\n</code></pre></p> <p>Danger</p> <p>Make sure, if you are using version control, to add <code>config.py</code> to your <code>.gitignore</code> file! This file contains all of your personal information, such as your password, and should not be shared with anyone.</p> <p>While you're at it, you should add the <code>store</code> directory to your <code>.gitignore</code> file as well, as that will contain encryption keys later on.</p>"},{"location":"guides/getting-started/#setting-up-configpy","title":"Setting up config.py","text":"<p>In our <code>config.py</code> file, we'll add the following: <pre><code>HOMESERVER = \"https://matrix.org\"\nUSER_ID = \"@my-username:matrix.org\"\nPASSWORD = \"my-password\"\n</code></pre></p> <p>Warning</p> <p>Make sure to replace the above with your own homeserver, user ID, and password!</p>"},{"location":"guides/getting-started/#making-the-bot-runtime-file","title":"Making the bot runtime file","text":"<p>And, to make a simple bot, you can just copy the below template into your <code>main.py</code> file: <pre><code>import niobot\nimport config\nbot = niobot.NioBot(\nhomeserver=config.HOMESERVER,\nuser_id=config.USER_ID,\ndevice_id='my-device-id',\nstore_path='./store',\ncommand_prefix=\"!\",\nowner_id=\"@my-matrix-username:matrix.org\"\n)\n# We also want to load `fun.py`'s commands before starting:\nbot.mount_module(\"fun\")  # looks at ./fun.py\n@bot.on_event(\"ready\")\nasync def on_ready(_):\n# That first argument is needed as the first result of the sync loop is passed to ready. Without it, this event\n# will fail to fire, and will cause a potentially catasrophic failure.\nprint(\"Bot is ready!\")\n@bot.command()\nasync def ping(ctx):  # can be invoked with \"!ping\"\nawait ctx.reply(\"Pong!\")\nbot.run(password=config.PASSWORD)\n</code></pre></p> About <code>owner_id</code> <p><code>owner_id</code> is intended to tell nio-bot who owns the current instance. Do not set this to be the same thing as <code>config.USER_ID</code> (your bot's ID)! The only time you should do that is if you want to run the bot on the same account you use.</p> <p>Otherwise, set this to be your own user ID, so that you can use any \"owner only\" commands.</p> <p>It is not necessary to set this though, so it can be omitted or set to <code>None</code>. Just note that <code>NioBot.is_owner(...)</code> will raise an error when used.</p>"},{"location":"guides/getting-started/#enabling-logging","title":"Enabling logging","text":"<p>You'll probably find that it's useful to enable debug logging while you're developing your bot. To do that, you can add the following to your <code>main.py</code> file: <pre><code>import logging\nimport niobot\nlogging.basicConfig(level=logging.DEBUG)\n# or to save to a file (uncomment):\n# logging.basicConfig(level=logging.DEBUG, filename=\"bot.log\")\nbot = niobot.NioBot(...)\n...\n</code></pre></p>"},{"location":"guides/getting-started/#making-funpy","title":"Making fun.py","text":"<p>Now, fun.py is going to be a module.</p> <p>Modules are a great way to organize your code, and make it easier to manage. They also allow you to easily add new commands to your bot without having to edit the main file, which means you can split your code up, and make it... modular!</p> <p>To start, we need to make the fun.py python file, and add the following: <pre><code>import niobot\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\ndef __init__(self, bot):\nself.bot = bot  # bot is the NioBot instance you made in main.py!\n</code></pre> And that's it! You made your module!</p>"},{"location":"guides/getting-started/#but-wait-theres-more","title":"But wait, there's more!","text":"<p>You may notice that with this being a separate module, you can't use <code>@bot.command</code>, or <code>@bot.on_event</code>, or reference <code>bot</code> at all!</p> <p>You'd initially assume \"Oh, I'll just import bot from main.\" - but that's not going to work. The reason for this is every time <code>main.py</code> is imported, it creates a new <code>NioBot</code>, and then... calls bot.run() at the end, meaning not only would your import never finish, but it would also cause a massive recursion bug!</p> <p>The way you get around this is instead with <code>@niobot.command()</code>. This is a decorator that will register the command with the bot, however is designed specifically with modules in mind.</p> <p>Let's compare the two, for simplicity:</p> <code>@niobot.NioBot.command()</code> <code>@niobot.command()</code> Adds commands to the register immediately Adds commands to the register once the module is loaded Can only be used at runtime, or wherever <code>bot</code> can be imported from Can only be used in modules (has no effect outside a<code>niobot.Module</code>!) Takes priority over <code>@niobot.command()</code> due to the immediate register Lower priority than <code>NioBot.command()</code> due to the \"lazy loading\" <p>Do be aware though, both decorators will take the exact same arguments as <code>niobot.Command</code>.</p>"},{"location":"guides/getting-started/#adding-a-command-to-funpy","title":"Adding a command to fun.py","text":"<p>So, let's add a command to our module: <pre><code>import niobot\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\ndef __init__(self, bot):\nself.bot = bot  # bot is the NioBot instance you made in main.py!\n@niobot.command()\nasync def hello(self, ctx):\nawait ctx.reply(\"Hello %s!\" % ctx.event.sender)\n</code></pre> This will add a command, <code>!hello</code>, that will reply with \"Hello {@author}!\"</p>"},{"location":"guides/getting-started/#starting-the-bot","title":"Starting the bot","text":"<p>Hold your horses, you're not quite ready yet!</p> <p>Generally, it's a terrible idea to always use a password in your code. It's a security risk, and in matrix it can result in creating many sessions, which you don't want, especially if you're using encryption!</p>"},{"location":"guides/getting-started/#getting-an-access-token","title":"Getting an access token","text":"<p>An access token is like a server-generated long-lived password. You will probably want one in order to repeatedly use the same session, and to avoid having to use your password in your code.</p> <p>You can get your password with <code>niocli get-access-token</code>. For example: <pre><code>(venv) [me@host test-niobot]$ niocli get-access-token\nUser ID (@username:homeserver.tld): @test:matrix.org\nPassword (will not echo): Device ID (a memorable display name for this login, such as 'bot-production') [host]: Resolving homeserver... OK\nGetting access token... OK\nAccess token: syt_&lt;...&gt;\n</code></pre></p> <p>What you're going to do now, is copy the full access token string, and open <code>config.py</code> again Now, replace <code>PASSWORD=...</code> with <code>ACCESS_TOKEN=\"syt_&lt;...&gt;\"</code>. Make sure to keep the quotes!</p> <p>You will also need to go into <code>main.py</code>, down to the last line, and replace <code>password=config.PASSWORD</code> with <code>access_token=config.ACCESS_TOKEN</code>.</p> What is <code>sso_token</code>? <p>SSO token is a <code>S</code>ingle <code>S</code>ign <code>O</code>n token, employed by the likes of Mozilla, and is often used for SAML. Chances are, if you don't know what it is, you definitely don't need it. And if you do need it, you already know what it is, why you need it, and how to get it.</p>"},{"location":"guides/getting-started/#actually-running-the-bot","title":"Actually running the bot","text":"<p>This is the really simple part, actually. All you need to do now is run <code>main.py</code>!</p> <pre><code>(venv) [me@host test-niobot]$ python main.py\n&lt;insert log spam here&gt;\nBot is ready!\n&lt;insert log spam here&gt;\n</code></pre> <p>Its taking FOREVER to log in! is something going wrong?</p> <p>Nope. It can often take a while (upwards of five minutes in some cases!) for the bot to log in. This is because, when you first start the bot, it has to sync your entire state with the server. This often results in a LOT of IO, and a lot of network waiting, etc.</p> <p>You can speed up this process in the future by:</p> <ul> <li>Making sure you have <code>store_path</code> and a valid store in your configuration. Stores mean that the bot doesn't have   to re-sync everything every time it starts up.</li> <li>Using an access token instead of a password. This means that the bot doesn't have to log in, and can just start   syncing immediately, even from the last time it was stopped, which saves a very very large portion of the time   taken</li> </ul>"},{"location":"guides/getting-started/#interesting-log-output","title":"Interesting log output","text":"<p>You may notice that, if you enabled logging, you get some interesting log output.</p> <p>Some things you will want to keep an eye out for:</p> <ul> <li><code>INFO:niobot.client:Encryption support enabled automatically.</code> - This means that you have set up requirements for the   bot to use encryption, and it has detected that it can use encryption, and automatically enabled it, which is good!</li> <li><code>DEBUG:niobot.client:&lt;module '...' from '...'&gt; does not have its own setup() - auto-discovering commands and events</code> - This   means that the bot has detected a module, and is automatically loading it. This is good for most cases.   You should only worry about this message if you defined your own setup function.</li> <li><code>DEBUG:niobot.client:Registered command &lt;Command name='...' aliases=[...] disabled=...&gt; into &lt;command_name&gt;</code> - This simply   means a command has been added to the internal register.</li> <li><code>DEBUG:niobot.client:Added event listener &lt;function &lt;function_name&gt; at &lt;address&gt;&gt; for '&lt;event_name&gt;'</code> - Like the above,   this simply means an event has been added to the internal register.</li> </ul>"},{"location":"guides/getting-started/#and-thats-it","title":"And that's it!","text":"<p>You've successfully made a bot, and got it running!</p>"},{"location":"guides/getting-started/#wait-how-do-i-use-it","title":"Wait, how do I use it?","text":"<p>nio-bot has a handy dandy auto-join feature - if you just invite your bot's user to a room, assuming all is correct, within a couple seconds, your bot will automatically join your room!</p> <p>Then, you can run <code>!help</code> to get a list of commands, and <code>!help &lt;command&gt;</code> to get help on a specific command.</p>"},{"location":"reference/attachment/","title":"Attachments","text":""},{"location":"reference/attachment/#niobot.attachment.Thumbnail","title":"Thumbnail","text":"<p>Represents a thumbnail for a media attachment.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the thumbnail.</p> required <code>mime</code> <code>str</code> <p>The mime type of the thumbnail.</p> required <code>height</code> <code>int</code> <p>The height of the thumbnail.</p> required <code>width</code> <code>int</code> <p>The width of the thumbnail.</p> required <code>size</code> <code>int</code> <p>The size of the thumbnail.</p> required"},{"location":"reference/attachment/#niobot.attachment.Thumbnail.from_attachment","title":"from_attachment  <code>classmethod</code>","text":"<pre><code>from_attachment(attachment: MediaAttachment)\n</code></pre> <p>Creates a thumbnail from a MediaAttachment.</p> <p>You should make sure you've <code>upload()</code>ed the attachment first.</p> <p>Parameters:</p> Name Type Description Default <code>attachment</code> <code>MediaAttachment</code> <p>The attachment to create the thumbnail from.</p> required <p>Returns:</p> Type Description <p>A Thumbnail object.</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment","title":"MediaAttachment","text":"<p>Represents an image, audio or video to be sent to a room.</p> You probably want to skip to from_file <p>The <code>MediaAttachment.from_file</code> method is the best way to create a MediaAttachment from just a file. You should (and realistically, only can) create an instance of this manually if you have the file, mime type, height, width, and optionally thumbnail already.</p> <p>The <code>MediaAttachment.from_file</code> method will automatically do this for you.</p> You can only use video/image/audio content with this class <p>Do not use this attachment type for anything other than video, image, or audio content. Use <code>FileAttachment</code> for other types of files.</p> BytesIO support is experimental <p>It is advised to write BytesIO objects to a temporary file if you experience any issues with them. This is because some methods, such as <code>MediaAttachment.upload</code>, re-open the file descriptor in an asynchronous context, which may cause issues with BytesIO.</p> <p>Initially, the library did this automatically, however to prevent compatibility issues, this is now just the responsibility of the developer.</p> <p>Using a BytesIO() will yield a warning in the logs, however may still work.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to send (either a path, BytesIO, or <code>pathlib.Path</code> object)</p> required <code>mime</code> <code>str</code> <p>The mime type of the file</p> <code>None</code> <code>height</code> <code>typing.Union[int, None]</code> <p>The height of the file, if applicable</p> required <code>width</code> <code>typing.Union[int, None]</code> <p>The width of the file, if applicable</p> required <code>thumbnail</code> <code>Thumbnail</code> <p>The thumbnail of the file, if applicable</p> <code>None</code> <code>blur_hash</code> <code>str</code> <p>The blurhash of the file, if applicable</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.media_type","title":"media_type  <code>property</code>","text":"<pre><code>media_type: str\n</code></pre> <p>The media type of the attachment, be it m.video, m.image, or m.audio.</p> <p>Returns:</p> Type Description <p><code>m.audio</code>, <code>m.image</code>, or <code>m.video</code></p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>Returns the size of the thumbnail in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.url","title":"url  <code>property</code>","text":"<pre><code>url: str | None\n</code></pre> <p>The current mxc URL of the attachment, if it has been uploaded.</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\nfile: pathlib.Path | str,\nthumbnail: Thumbnail = None,\ngen_blur_hash: bool = True,\n) -&gt; MediaAttachment\n</code></pre> <p>Creates a MediaAttachment from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>pathlib.Path | str</code> <p>The file to create the attachment from (Must be a path or pathlib.Path object, cannot be BytesIO)</p> required <code>thumbnail</code> <code>Thumbnail</code> <p>The thumbnail of the file, if applicable</p> <code>None</code> <code>gen_blur_hash</code> <code>bool</code> <p>Whether to generate a blurhash for the file</p> <code>True</code> <p>Returns:</p> Type Description <code>MediaAttachment</code> <p>A MediaAttachment object</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(client: NioBot, file_name: str = None)\n</code></pre> <p>Uploads the file to matrix.</p>"},{"location":"reference/attachment/#niobot.attachment.MediaAttachment.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the attachment to a dictionary.</p>"},{"location":"reference/attachment/#niobot.attachment.FileAttachment","title":"FileAttachment","text":"<p>         Bases: <code>MediaAttachment</code></p> <p>Represents a generic file type, such as PDF or TXT.</p> <p>Do not use this class for images, audio or video.</p> <p>Do not use this class for images, audio or video. Use <code>MediaAttachment</code> instead. Furthermore, you should initialise this class manually - the <code>from_file</code> method does so much unnecessary work that it's not worth using for this attachment type.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to upload.</p> required <code>mime_type</code> <code>str</code> <p>The mime type of the file. If not specified, it will be detected automatically.</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.FileAttachment.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the attachment to a dictionary.</p>"},{"location":"reference/attachment/#niobot.attachment.detect_mime_type","title":"detect_mime_type","text":"<pre><code>detect_mime_type(\nfile: typing.Union[str, io.BytesIO, pathlib.Path]\n) -&gt; str\n</code></pre> <p>Detect the mime type of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to detect the mime type of. Can be a BytesIO.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The mime type of the file (e.g. <code>text/plain</code>, <code>image/png</code>, <code>application/pdf</code>, <code>video/webp</code> etc.)</p>"},{"location":"reference/attachment/#niobot.attachment.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(\nfile: typing.Union[str, pathlib.Path]\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>Gets metadata for a file via ffprobe.</p> Example result <pre><code>{\n\"streams\": [\n{\n\"index\": 0,\n\"codec_name\": \"h264\",\n\"codec_long_name\": \"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\",\n\"profile\": \"High\",\n\"codec_type\": \"video\",\n...\n}\n],\n\"format\": {\n\"filename\": \"./assets/peek.mp4\",\n\"format_long_name\": \"QuickTime / MOV\",\n\"start_time\": \"0.000000\",\n\"duration\": \"16.283333\",\n\"size\": \"4380760\",\n\"bit_rate\": \"2152266\",\n...\n}\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, pathlib.Path]</code> <p>The file to get metadata for. Must be a path-like object</p> required <p>Returns:</p> Type Description <code>typing.Dict[str, typing.Any]</code> <p>A dictionary containing the metadata.</p>"},{"location":"reference/attachment/#niobot.attachment.first_frame","title":"first_frame","text":"<pre><code>first_frame(\nfile: str | pathlib.Path, file_format: str = \"webp\"\n) -&gt; bytes\n</code></pre> <p>Gets the first frame of a video file.</p> <p>This function creates a file on disk</p> <p>In order to extract the frame, this function creates a temporary file on disk (or memdisk depending on where your tempdir is). While this file is deleted after the function is done, it is still something to be aware of. For example, if you're (worryingly) low on space, this function may fail to extract the frame due to a lack of space. Or, someone could temporarily access and read the file before it is deleted.</p> <p>This also means that this function may be slow.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | pathlib.Path</code> <p>The file to get the first frame of. Must be a path-like object</p> required <code>file_format</code> <code>str</code> <p>The format to save the frame as. Defaults to webp.</p> <code>'webp'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The first frame of the video in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.generate_blur_hash","title":"generate_blur_hash","text":"<pre><code>generate_blur_hash(file: str | pathlib.Path) -&gt; str\n</code></pre> <p>Creates a blurhash</p> <p>This function may be resource intensive</p> <p>This function may be resource intensive, especially for large images. You should run this in a thread or process pool.</p> <p>You should also scale any images down in order to increase performance.</p> <p>See: woltapp/blurhash</p>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#niobot.client.NioBot","title":"NioBot","text":"<p>         Bases: <code>nio.AsyncClient</code></p> <p>The main client for NioBot.</p> <p>Parameters:</p> Name Type Description Default <code>homeserver</code> <code>str</code> <p>The homeserver to connect to. e.g. https://matrix-client.matrix.org</p> required <code>user_id</code> <code>str</code> <p>The user ID to log in as. e.g. @user:matrix.org</p> required <code>device_id</code> <code>str</code> <p>The device ID to log in as. e.g. nio-bot</p> <code>'nio-bot'</code> <code>store_path</code> <code>str</code> <p>The path to the store file. Defaults to ./store. Must be a directory.</p> <code>None</code> <code>command_prefix</code> <code>str</code> <p>The prefix to use for commands. e.g. !</p> required <code>case_insensitive</code> <code>bool</code> <p>Whether to ignore case when checking for commands. If True, this lower()s incoming messages for parsing.</p> <code>True</code> <code>global_message_type</code> <code>str</code> <p>The message type to default to. Defaults to m.notice</p> <code>'m.notice'</code> <code>ignore_old_events</code> <code>bool</code> <p>Whether to simply discard events before the bot's login.</p> <code>True</code> <code>owner_id</code> <code>str</code> <p>The user ID of the bot owner. If set, only this user can run owner-only commands, etc.</p> <code>None</code>"},{"location":"reference/client/#niobot.client.NioBot.commands","title":"commands  <code>property</code>","text":"<pre><code>commands: typing.Dict[str, Command]\n</code></pre> <p>Returns the internal command register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p> <p>Note</p> <p>Aliases of commands are treated as their own command instance. You will see the same command show up as a value multiple times if it has aliases.</p>"},{"location":"reference/client/#niobot.client.NioBot.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: typing.Dict[typing.Type[Module], Module]\n</code></pre> <p>Returns the internal module register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p>"},{"location":"reference/client/#niobot.client.NioBot.latency","title":"latency  <code>staticmethod</code>","text":"<pre><code>latency(\nevent: nio.Event, *, received_at: float = None\n) -&gt; float\n</code></pre> <p>Returns the latency for a given event in milliseconds</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>nio.Event</code> <p>The event to measure latency with</p> required <code>received_at</code> <code>float</code> <p>The optional time the event was received at. If not given, uses the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The latency in milliseconds</p>"},{"location":"reference/client/#niobot.client.NioBot.dispatch","title":"dispatch","text":"<pre><code>dispatch(event_name: str, *args: str, **kwargs: str)\n</code></pre> <p>Dispatches an event to listeners</p>"},{"location":"reference/client/#niobot.client.NioBot.is_old","title":"is_old","text":"<pre><code>is_old(event: nio.Event) -&gt; bool\n</code></pre> <p>Checks if an event was sent before the bot started. Always returns False when ignore_old_evens is False</p>"},{"location":"reference/client/#niobot.client.NioBot.update_read_receipts","title":"update_read_receipts  <code>async</code>","text":"<pre><code>update_read_receipts(room, event)\n</code></pre> <p>part of spec module 11.6</p>"},{"location":"reference/client/#niobot.client.NioBot.process_message","title":"process_message  <code>async</code>","text":"<pre><code>process_message(\nroom: nio.MatrixRoom, event: nio.RoomMessageText\n)\n</code></pre> <p>Processes a message and runs the command it is trying to invoke if any.</p>"},{"location":"reference/client/#niobot.client.NioBot.is_owner","title":"is_owner","text":"<pre><code>is_owner(user_id: str) -&gt; bool\n</code></pre> <p>Checks whether a user is the owner of the bot.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The user ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user is the owner.</p>"},{"location":"reference/client/#niobot.client.NioBot.mount_module","title":"mount_module","text":"<pre><code>mount_module(\nimport_path: str,\n) -&gt; typing.Optional[list[Command]]\n</code></pre> <p>Mounts a module including all of its commands.</p> <p>Must be a subclass of niobot.commands.Module, or else this function will not work.</p> <p>Parameters:</p> Name Type Description Default <code>import_path</code> <code>str</code> <p>The import path (such as modules.file), which would be ./modules/file.py in a file tree.</p> required <p>Returns:</p> Type Description <code>typing.Optional[list[Command]]</code> <p>Optional[List[Command]] - A list of commands mounted. None if the module's setup() was called.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>The module path is incorrect of there was another error while importing</p> <code>TypeError</code> <p>The module was not a subclass of Module.</p> <code>ValueError</code> <p>There was an error registering a command (e.g. name conflict)</p>"},{"location":"reference/client/#niobot.client.NioBot.get_command","title":"get_command","text":"<pre><code>get_command(name: str) -&gt; Command | None\n</code></pre> <p>Attempts to retrieve an internal command</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command to retrieve</p> required <p>Returns:</p> Type Description <code>Command | None</code> <p>The command, if found. None otherwise.</p>"},{"location":"reference/client/#niobot.client.NioBot.add_command","title":"add_command","text":"<pre><code>add_command(command: Command) -&gt; None\n</code></pre> <p>Adds a command to the internal register</p> <p>if a name or alias is already registered, this throws a ValueError. Otherwise, it returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.remove_command","title":"remove_command","text":"<pre><code>remove_command(command: Command) -&gt; None\n</code></pre> <p>Removes a command from the internal register.</p> <p>If the command is not registered, this is a no-op.</p>"},{"location":"reference/client/#niobot.client.NioBot.command","title":"command","text":"<pre><code>command(name: str = None, **kwargs: str)\n</code></pre> <p>Registers a command with the bot.</p>"},{"location":"reference/client/#niobot.client.NioBot.on_event","title":"on_event","text":"<pre><code>on_event(event_type: str = None)\n</code></pre> <p>Wrapper that allows you to register an event handler</p>"},{"location":"reference/client/#niobot.client.NioBot.room_send","title":"room_send  <code>async</code>","text":"<pre><code>room_send(\nroom_id: str,\nmessage_type: str,\ncontent: dict,\ntx_id: str | None = None,\nignore_unverified_devices: bool = True,\n) -&gt; nio.RoomSendResponse | nio.RoomSendError\n</code></pre> <p>Send a message to a room. Wrapper. See :meth:<code>nio.AsyncClient.room_send</code> for more information.</p>"},{"location":"reference/client/#niobot.client.NioBot.get_cached_message","title":"get_cached_message","text":"<pre><code>get_cached_message(\nevent_id: str,\n) -&gt; typing.Optional[\ntyping.Tuple[nio.MatrixRoom, nio.RoomMessageText]\n]\n</code></pre> <p>Fetches a message from the cache.</p> <p>This returns both the room the message was sent in, and the event itself.</p> <p>If the message is not in the cache, this returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.fetch_message","title":"fetch_message  <code>async</code>","text":"<pre><code>fetch_message(room_id: str, event_id: str)\n</code></pre> <p>Fetches a message from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.wait_for_message","title":"wait_for_message  <code>async</code>","text":"<pre><code>wait_for_message(\nroom_id: str = None,\nsender: str = None,\ncheck: typing.Callable[\n[nio.MatrixRoom, nio.RoomMessageText], typing.Any\n] = None,\n*,\ntimeout: float = None\n) -&gt; typing.Optional[\ntyping.Tuple[nio.MatrixRoom, nio.RoomMessageText]\n]\n</code></pre> <p>Waits for a message, optionally with a filter.</p> <p>If this function times out, asyncio.TimeoutError is raised.</p>"},{"location":"reference/client/#niobot.client.NioBot.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(\nroom: nio.MatrixRoom | str,\ncontent: str = None,\nfile: MediaAttachment = None,\nreply_to: nio.RoomMessageText | str = None,\nmessage_type: str = None,\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Sends a message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room to send this message to</p> required <code>content</code> <code>str</code> <p>The content to send. Cannot be used with file.</p> <code>None</code> <code>file</code> <code>MediaAttachment</code> <p>A file to send, if any. Cannot be used with content.</p> <code>None</code> <code>reply_to</code> <code>nio.RoomMessageText | str</code> <p>A message to reply to.</p> <code>None</code> <code>message_type</code> <code>str</code> <p>The message type to send. If none, defaults to NioBot.global_message_type, which itself is <code>m.notice</code> by default.</p> <code>None</code> <p>Returns:</p> Type Description <code>nio.RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to send, or if the file fails to upload.</p> <code>ValueError</code> <p>You specified neither file nor content.</p>"},{"location":"reference/client/#niobot.client.NioBot.edit_message","title":"edit_message  <code>async</code>","text":"<pre><code>edit_message(\nroom: nio.MatrixRoom | str,\nevent_id: nio.Event | str,\ncontent: str,\n*,\nmessage_type: str = None\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Edit an existing message. You must be the sender of the message.</p> <p>You also cannot edit messages that are attachments.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>event_id</code> <code>nio.Event | str</code> <p>The message to edit.</p> required <code>content</code> <code>str</code> <p>The new content of the message.</p> required <code>message_type</code> <code>str</code> <p>The new type of the message (i.e. m.text, m.notice. Defaults to client.global_message_type)</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>TypeError</code> <p>If the message is not text.</p>"},{"location":"reference/client/#niobot.client.NioBot.delete_message","title":"delete_message  <code>async</code>","text":"<pre><code>delete_message(\nroom: nio.MatrixRoom | str,\nmessage_id: nio.RoomMessage | str,\nreason: str = None,\n) -&gt; nio.RoomRedactResponse\n</code></pre> <p>Delete an existing message. You must be the sender of the message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>message_id</code> <code>nio.RoomMessage | str</code> <p>The message to delete.</p> required <code>reason</code> <code>str</code> <p>The reason for deleting the message.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p>"},{"location":"reference/client/#niobot.client.NioBot.start","title":"start  <code>async</code>","text":"<pre><code>start(\npassword: str = None,\naccess_token: str = None,\nsso_token: str = None,\n) -&gt; None\n</code></pre> <p>Starts the bot, running the sync loop.</p>"},{"location":"reference/client/#niobot.client.NioBot.run","title":"run","text":"<pre><code>run(\n*,\npassword: str = None,\naccess_token: str = None,\nsso_token: str = None\n) -&gt; None\n</code></pre> <p>Runs the bot, blocking the program until the event loop exists. This should be the last function to be called in your script, as once it exits, the bot will stop running.</p> <p>Note:     This function is literally just asyncio.run(NioBot.start(...)), so you won't have much control over the     asyncio event loop. If you want more control, you should use await NioBot.start(...) instead.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to log in with.</p> <code>None</code> <code>access_token</code> <code>str</code> <p>An existing login token.</p> <code>None</code> <code>sso_token</code> <code>str</code> <p>An SSO token to sign in with.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/commands/","title":"Commands","text":"<p>Using commands and events is the main way to interact with the bot.</p>"},{"location":"reference/commands/#niobot.commands.Argument","title":"Argument","text":"<p>Represents a command argument.</p> Example <pre><code>from niobot import NioBot, command, Argument\nbot = NioBot(...)\n@bot.command(\"echo\", arguments=[Argument(\"message\", str)])\ndef echo(ctx: niobot.Context, message: str):\nawait ctx.respond(message)\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument. Will be used to know which argument to pass to the command callback.</p> required <code>arg_type</code> <code>_T</code> <p>The type of the argument (e.g. str, int, etc. or a custom type)</p> required <code>description</code> <code>str</code> <p>The description of the argument. Will be shown in the auto-generated help command.</p> <code>None</code> <code>default</code> <code>typing.Any</code> <p>The default value of the argument</p> <code>Ellipsis</code> <code>required</code> <code>bool</code> <p>Whether the argument is required or not. Defaults to True if default is ..., False otherwise.</p> <code>Ellipsis</code>"},{"location":"reference/commands/#niobot.commands.Argument.internal_parser","title":"internal_parser  <code>staticmethod</code>","text":"<pre><code>internal_parser(\n_: Context, arg: Argument, value: str\n) -&gt; typing.Optional[_T]\n</code></pre> <p>The default parser for the argument. Will try to convert the value to the argument type.</p>"},{"location":"reference/commands/#niobot.commands.Command","title":"Command","text":"<p>Represents a command.</p> Example <p>Note</p> <p>This example uses the <code>command</code> decorator, but you can also use the <code>Command</code> class directly, but you likely won't need to, unless you want to pass a custom command class.</p> <p>All that the <code>@command</code> decorator does is create a <code>Command</code> instance and add it to the bot's commands, while wrapping the function its decorating.</p> <pre><code>from niobot import NioBot, command\nbot = NioBot(...)\n@bot.command(\"hello\")\ndef hello(ctx: niobot.Context):\nawait ctx.respond(\"Hello, %s!\" % ctx.message.sender)\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Will be used to invoke the command.</p> required <code>callback</code> <code>callable</code> <p>The callback to call when the command is invoked.</p> required <code>aliases</code> <code>list[str]</code> <p>The aliases of the command. Will also be used to invoke the command.</p> <code>None</code> <code>description</code> <code>str</code> <p>The description of the command. Will be shown in the auto-generated help command.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the command is disabled or not. If disabled, the command will be hidden on the auto-generated help command, and will not be able to be invoked.</p> <code>False</code> <code>arguments</code> <p>A list of <code>Argument</code> instances. Will be used to parse the arguments given to the command. <code>ctx</code> is always the first argument, regardless of what you put here.</p> required <code>usage</code> <p>A string representing how to use this command's arguments. Will be shown in the auto-generated help. Do not include the command name or your bot's prefix here, only arguments.</p> required"},{"location":"reference/commands/#niobot.commands.Command.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if another command's runtime ID is the same as this one's</p>"},{"location":"reference/commands/#niobot.commands.Command.invoke","title":"invoke","text":"<pre><code>invoke(ctx: Context)\n</code></pre> <p>Invokes the current command with the given context</p>"},{"location":"reference/commands/#niobot.commands.Module","title":"Module","text":""},{"location":"reference/commands/#niobot.commands.Module.__setup__","title":"__setup__","text":"<pre><code>__setup__()\n</code></pre> <p>Setup function called once by NioBot.mount_module(). Mounts every command discovered.</p>"},{"location":"reference/commands/#niobot.commands.Module.__teardown__","title":"__teardown__","text":"<pre><code>__teardown__()\n</code></pre> <p>Teardown function called once by NioBot.unmount_module(). Removes any command that was mounted.</p>"},{"location":"reference/commands/#niobot.commands.command","title":"command","text":"<pre><code>command(name: str = None, **kwargs: str) -&gt; callable\n</code></pre> <p>Allows you to register commands later on, by loading modules.</p> <p>This differs from NioBot.command() in that commands are not automatically added, you need to load them with bot.mount_module</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Defaults to function.name</p> <code>None</code> <code>kwargs</code> <p>Any key-words to pass to Command</p> <code>{}</code> <p>Returns:</p> Type Description <code>callable</code>"},{"location":"reference/commands/#niobot.commands.event","title":"event","text":"<pre><code>event(name: str) -&gt; callable\n</code></pre> <p>Allows you to register event listeners in modules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the event (no <code>on_</code> prefix)</p> required <p>Returns:</p> Type Description <code>callable</code>"},{"location":"reference/context/","title":"Context","text":"<p>For each command invoked, the first argument is always a <code>Context</code> instance, which holds a lot of metadata, and a few utility functions to help you write commands.</p> <p>A lot of the time, these are the three main attributes you'll be using:</p> <ul> <li><code>Context.room</code> (<code>nio.MatrixRoom</code>) - the room the command was invoked in.</li> <li><code>Context.event</code> (<code>nio.RoomMessageText</code>) - the message that invoked this command.</li> <li><code>Context.respond</code> - a utility class to help you respond to the command.</li> </ul>"},{"location":"reference/context/#command-context","title":"Command Context","text":"<p>Event-based context for a command callback</p>"},{"location":"reference/context/#niobot.context.Context.room","title":"room  <code>property</code>","text":"<pre><code>room: nio.MatrixRoom\n</code></pre> <p>The room that the event was dispatched in</p>"},{"location":"reference/context/#niobot.context.Context.client","title":"client  <code>property</code>","text":"<pre><code>client: NioBot\n</code></pre> <p>The current instance of the client</p>"},{"location":"reference/context/#niobot.context.Context.command","title":"command  <code>property</code>","text":"<pre><code>command: Command\n</code></pre> <p>The current command being invoked</p>"},{"location":"reference/context/#niobot.context.Context.args","title":"args  <code>property</code>","text":"<pre><code>args: list[str]\n</code></pre> <p>Each argument given to this command</p>"},{"location":"reference/context/#niobot.context.Context.message","title":"message  <code>property</code>","text":"<pre><code>message: nio.RoomMessageText\n</code></pre> <p>The current message</p>"},{"location":"reference/context/#niobot.context.Context.original_response","title":"original_response  <code>property</code>","text":"<pre><code>original_response: typing.Optional[nio.RoomSendResponse]\n</code></pre> <p>The result of Context.reply(), if it exists.</p>"},{"location":"reference/context/#niobot.context.Context.latency","title":"latency  <code>property</code>","text":"<pre><code>latency: float\n</code></pre> <p>Returns the current event's latency in milliseconds.</p>"},{"location":"reference/context/#niobot.context.Context.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(\ncontent: str = None, file: MediaAttachment = None\n) -&gt; ContextualResponse\n</code></pre> <p>Responds to the current event.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text to reply with</p> <code>None</code> <code>file</code> <code>MediaAttachment</code> <p>A file to reply with</p> <code>None</code> <p>Returns:</p> Type Description <code>ContextualResponse</code>"},{"location":"reference/context/#contextual-response","title":"Contextual Response","text":"<p>Context class for managing replies.</p> <p>Usage of this function is not required, however it is a useful utility.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.message","title":"message  <code>property</code>","text":"<pre><code>message: nio.RoomMessageText | None\n</code></pre> <p>Fetches the current message for this response</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.reply","title":"reply  <code>async</code>","text":"<pre><code>reply(*args) -&gt; ContextualResponse\n</code></pre> <p>Replies to the current response.</p> <p>This does NOT reply to the original invoking message.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>args to pass to send_message</p> <code>()</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>a new ContextualResponse object.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(content: str, **kwargs: str) -&gt; ContextualResponse\n</code></pre> <p>Edits the current response.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The new content to edit with</p> required <code>kwargs</code> <p>Any extra arguments to pass to Client.edit_message</p> <code>{}</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>self</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(reason: str = None) -&gt; None\n</code></pre> <p>Redacts the current response.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>An optional reason for the redaction</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None, as there will be no more response.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#niobot.exceptions.NioBotException","title":"NioBotException","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for NioBot.</p> <p>Warning</p> <p>In some rare cases, all of <code>exception</code>, <code>response</code> and <code>original</code> may be None.</p> <p>All other exceptions raised by this library will subclass this exception, so at least all the below are always available:</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str | None</code> <p>A simple humanised explanation of the issue, if available.</p> <code>response</code> <code>nio.ErrorResponse | None</code> <p>The response object from the server, if available.</p> <code>exception</code> <code>typing.Union[nio.ErrorResponse, Exception]</code> <p>The exception that was raised, if available.</p> <code>original</code> <code>nio.ErrorResponse | Exception | None</code> <p>The original response, or exception if response was not available.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a human-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Returns a developer-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MessageException","title":"MessageException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for message-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.LoginException","title":"LoginException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for login-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaUploadException","title":"MediaUploadException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for media-uploading related errors</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandError","title":"CommandError","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception subclass for all command invocation related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandDisabledError","title":"CommandDisabledError","text":"<p>         Bases: <code>CommandError</code></p> <p>Exception raised when a command is disabled.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandArgumentsError","title":"CommandArgumentsError","text":"<p>         Bases: <code>CommandError</code></p> <p>Exception subclass for command argument related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandParserError","title":"CommandParserError","text":"<p>         Bases: <code>CommandArgumentsError</code></p> <p>Exception raised when there is an error parsing arguments.</p>"},{"location":"reference/utils/federation/","title":"Federation","text":"<p>There isn't a lot here aside from a homeserver resolver. A lot of the federation is already handled by matrix-nio itself, so there isn't a lot of need for federation-specific utilities.</p>"},{"location":"reference/utils/federation/#niobot.utils.federation.resolve_homeserver","title":"resolve_homeserver  <code>async</code>","text":"<pre><code>resolve_homeserver(domain: str) -&gt; str\n</code></pre> <p>Resolves a given homeserver part to the actual homeserver</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain to crawl</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resolved homeserver</p>"},{"location":"reference/utils/help_command/","title":"The help command","text":"<p><code>NioBot</code> comes with a built-in help command, which can be used to display information about other commands.</p> <p>This built-in command is simple, slick, and most importantly, helpful. It takes one optional argument, <code>command</code>, which changes the output to display information about a specific command. Without this, the help command will list every enabled command, their aliases, a short help string, and a short description about the command (by default, the first line of the docstring).</p> <p>This allows for you to easily just add commands and not have to worry about documenting them outside of simply defining their usage in the command decorator, and a short description in the docstring.</p> An example of the help command with no arguments Source of this sample <p>This is the output of the help command from  EEKIM10/niobot-test</p> <pre><code>?[help|h]: Shows a list of commands for this bot\n?[ytdl|yt|dl|yl-dl|yt-dlp] &lt;url&gt; [format]: Downloads a video from YouTube\n?[quote|q]: Generate a random quote.\n?ping: Shows the roundtrip latency\n?info: Shows information about the bot\n?cud: Creates, updates, and deletes a message\n?upload &lt;type: image|video|audio|file&gt;: Uploads an image\n?hello: Asks for an input\n?version: Shows the version of nio\n?[pretty-print|pp]: Pretty prints given JSON\n?eval: Evaluates Python code\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p> An example of the help command with a specified command name Source of this sample <p>This is the output of the help command from  EEKIM10/niobot-test</p> <pre><code>?[help|h]:\nShows a list of commands for this bot\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p>"},{"location":"reference/utils/help_command/#registering-your-own-help-command","title":"Registering your own help command","text":"<p>If you would like to register your own help command, you need to be aware of the following:</p> <ul> <li>The help command is a command, much like any other command, and is registered as such. You should be aware of  aliases, case sensitivity, command states (e.g. disabled/enabled), etc.</li> <li>A help command is almost always a user's first impression of your bot. You should make sure that it works 100% of the time, is insanely simple to use, and is very helpful. A help command that just says \"You can use command like ?info\" is not helpful at all, and will likely turn many users away.</li> </ul> <p>???+ question Are there any dangers to these help commands?</p>"},{"location":"reference/utils/help_command/#help-command-functions","title":"Help Command functions:","text":""},{"location":"reference/utils/help_command/#niobot.utils.help_command.clean_output","title":"clean_output","text":"<pre><code>clean_output(\ntext: str,\n*,\nescape_user_mentions: bool = True,\nescape_room_mentions: bool = True,\nescape_room_references: bool = False,\nescape_all_periods: bool = False,\nescape_all_at_signs: bool = False,\nescape_method: typing.Callable[[str], str] = None\n) -&gt; str\n</code></pre> <p>Escapes given text and sanitises it, ready for outputting to the user.</p> <p>This should always be used when echoing any sort of user-provided content, as we all know there will be some annoying troll who will just go <code>@room</code> for no apparent reason every 30 seconds.</p> <p>Do not rely on this!</p> <p>This function is not guaranteed to escape all possible mentions, and should not be relied upon to do so. It is only meant to be used as a convenience function for simple commands.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to sanitise</p> required <code>escape_user_mentions</code> <code>bool</code> <p>Escape all @user:homeserver.tld mentions</p> <code>True</code> <code>escape_room_mentions</code> <code>bool</code> <p>Escape all @room mentions</p> <code>True</code> <code>escape_room_references</code> <code>bool</code> <p>Escape all #room:homeserver.tld references</p> <code>False</code> <code>escape_all_periods</code> <code>bool</code> <p>Escape all literal <code>.</code> characters (can be used to escape all links)</p> <code>False</code> <code>escape_all_at_signs</code> <code>bool</code> <p>Escape all literal <code>@</code> characters (can be used to escape all mentions)</p> <code>False</code> <code>escape_method</code> <code>typing.Callable[[str], str]</code> <p>A custom escape method to use instead of the built-in one (which just wraps characters in <code>\\u200b</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The cleaned text</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.format_command_name","title":"format_command_name","text":"<pre><code>format_command_name(command: Command) -&gt; str\n</code></pre> <p>Formats the command name with its aliases if applicable</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.format_command_line","title":"format_command_line","text":"<pre><code>format_command_line(prefix: str, command: Command) -&gt; str\n</code></pre> <p>Formats a command line, including name(s) &amp; usage.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.get_short_description","title":"get_short_description","text":"<pre><code>get_short_description(command: Command) -&gt; str\n</code></pre> <p>Generates a short (&lt;100 characters) help description for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.get_long_description","title":"get_long_description","text":"<pre><code>get_long_description(command: Command) -&gt; str\n</code></pre> <p>Gets the full help text for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.help_command_callback","title":"help_command_callback  <code>async</code>","text":"<pre><code>help_command_callback(ctx: Context)\n</code></pre> <p>Displays help text</p>"},{"location":"reference/utils/parsers/","title":"Parsers","text":"<p>These are a handful of built-in parsers that you can use with <code>niobot.Argument</code>.</p> How do I use these? <p>To use a parser, you simply pass <code>parser=&lt;function&gt;</code> when creating <code>Argument()</code>. For example:</p> <pre><code>from niobot import Argument, command, NioBot\nfrom niobot.utils.parsers import float_parser\nbot = NioBot(...)\n@bot.command(\nname=\"sum\", \narguments=[\nArgument(\"num1\", parser=float_parser),\nArgument(\"num2\", parser=float_parser)\n]\n)\nasync def add_numbers(ctx: Context, num1: float, num2: float):\nawait ctx.respond(\"{!s} + {!s} = {!s}\".format(num1, num2, num1 + num2))\nbot.run(...)\n</code></pre> <p>While this is roughly equivalent to <code>Argument(\"num1\", type=float)</code>, it can be helpful in cases like  json_parser where you need to parse complex types.</p> <p>Tip</p> <p>You can also create your own parsers! See Creating Parsers for more information.</p> <p>This utility modules contains a handful of simple off-the-shelf parser for some basic python types.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.boolean_parser","title":"boolean_parser","text":"<pre><code>boolean_parser(_: Context, __: Context, value: str) -&gt; bool\n</code></pre> <p>Converts a given string into a boolean. Value is lower-cased before being parsed.</p> <p>The following resolves to true:     1, y, yes, true, on</p> <p>The following resolves to false:     0, n, no, false, off</p> <p>The following will raise a command argument error: anything else</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The parsed boolean</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.float_parser","title":"float_parser","text":"<pre><code>float_parser(_: Context, __: Argument, value: str) -&gt; float\n</code></pre> <p>Converts a given string into a floating point number.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <code>Argument</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>float</code> <p>A parsed boolean</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.integer_parser","title":"integer_parser","text":"<pre><code>integer_parser(\nallow_floats: bool = False, base: int = 10\n) -&gt; typing.Callable[\n[Context, Argument, str], typing.Union[int, float]\n]\n</code></pre> <p>Converts a given value into an integer, or a float if allowed.</p> <p>Parameters:</p> Name Type Description Default <code>allow_floats</code> <code>bool</code> <p>Whether to allow parsing for floating numbers (decimals). Defaults to False.</p> <code>False</code> <code>base</code> <code>int</code> <p>The base to parse (defaults to base 10, denary)</p> <code>10</code> <p>Returns:</p> Type Description <code>typing.Callable[[Context, Argument, str], typing.Union[int, float]]</code> <p>The parsed number.</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.json_parser","title":"json_parser","text":"<pre><code>json_parser(\n_: Context, __: Argument, value: str\n) -&gt; typing.Union[\nlist, dict, str, int, float, type(None), bool\n]\n</code></pre> <p>Converts a given string into a JSON object.</p> <p>.. Note::     If you want this to be fast, you should install orjson. It is a drop-in replacement for the standard library.     While the parser will still work without it, it may be slower, especially for larger payloads.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <code>Argument</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>typing.Union[list, dict, str, int, float, type(None), bool]</code> <p>The parsed JSON object</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid JSON object.</p>"},{"location":"reference/utils/parsers/#creating-parsers","title":"Creating Parsers","text":"<p>Creating your own parser is actually really easy. All the library needs from you is a function that:</p> <ul> <li>Takes <code>niobot.Context</code> as its first argument</li> <li>Takes <code>niobot.Argument</code> as its second argument</li> <li>Takes a <code>str</code>ing (the user's input) as its third argument</li> <li>Returns a sensible value</li> <li>Or, raises CommandArgumentsError with a helpful error message.</li> </ul> <p>Do all of this, and you can very easily just pass this to <code>Argument</code>!</p> <p>For example, if you wanted to take a <code>datetime</code>, you could write your own parser like this:</p> <pre><code>from datetime import datetime\nfrom niobot import Argument, command, NioBot\ndef datetime_parser(ctx: Context, arg: Argument, user_input: str):\ntry:\nreturn datetime.strptime(user_input, \"%Y-%m-%d %H:%M:%S\")\nexcept ValueError:\nraise CommandArgumentsError(\"Invalid datetime format. Expected YYYY-MM-DD HH:MM:SS\")\nbot = NioBot(...)\n@bot.command(name=\"remindme\", arguments=[Argument(\"time\", arg_type=datetime, parser=datetime_parser)])\nasync def remind_me(ctx: Context, time: datetime):\nawait ctx.respond(\"I'll remind you at {}!\".format(time.strftime(\"%c\")))\nbot.run(...)\n</code></pre>"},{"location":"reference/utils/string_view/","title":"String View","text":"<p>This is mostly an internal utility.</p> <p>The ArgumentView is mostly used by the internal command parser to parse arguments. While you will be able to use this yourself, its very unlikely that you'll ever actually need it.</p> <p>This is a work in progress.</p> <p>The string view does a lot of complicated maths and logic to determine arguments. It's not as simple as just splitting the string on every whitespace and calling it an argument, the ArgumentView parser has to check for quotes, escape characters, and more.</p> <p>Due to the complexity of the parser, it's very likely that there are still bugs in the parser. Fixes welcome!</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView","title":"ArgumentView","text":"<p>A parser designed to allow for multi-word arguments and quotes</p> <p>For example, the arguments <code>1 \"2 3\" 4</code> would result in three items in the internal list: <code>1</code>, <code>2 3</code>, and <code>4</code></p> <p>This is most useful when parsing arguments from a command, as it allows for multi-word arguments.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse</p> required"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.eof","title":"eof  <code>property</code>","text":"<pre><code>eof: bool\n</code></pre> <p>Returns whether the parser has reached the end of the string</p> <p>Returns:</p> Type Description <p>Whether the parser has reached the end of the string (cursor is greater than or equal to the length of the string)</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.add_arg","title":"add_arg","text":"<pre><code>add_arg(argument: str) -&gt; None\n</code></pre> <p>Adds an argument to the argument list</p> <p>Parameters:</p> Name Type Description Default <code>argument</code> <code>str</code> <p>The argument to add</p> required <p>Returns:</p> Type Description <code>None</code> <p>none</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.parse_arguments","title":"parse_arguments","text":"<pre><code>parse_arguments() -&gt; ArgumentView\n</code></pre> <p>Main parsing engine.</p> <p>Returns:</p> Type Description <code>ArgumentView</code> <p>self</p>"},{"location":"reference/utils/typing/","title":"Typing helper","text":"<p>This utility module contains one tool: the <code>Typing</code> class. It is internally used in the <code>&lt;send/edit/delete&gt;_message</code> functions of <code>NioBot</code>, but you can use it at any point to send typing events to the chat.</p>"},{"location":"reference/utils/typing/#usage","title":"Usage","text":"<p>Context manager to manage typing notifications.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The <code>NioBot</code> instance</p> required <code>room_id</code> <code>str</code> <p>The room id to send the typing notification to</p> required <code>timeout</code> <code>int</code> <p>The timeout in seconds</p> <code>30</code> <code>persistent</code> <code>bool</code> <p>Whether to send a typing notification every <code>timeout</code> seconds, to keep the typing status active</p> <code>True</code> <p>Warning</p> <p>Nesting <code>Typing</code> instances for one specific room is a bad idea, as when each instance is exited, it stops typing for the given room. For example, the below will not work as expected:</p> <pre><code>from niobot import NioBot, utils\nbot = NioBot(...)\n@bot.command()\nasync def ping(ctx):\nasync with utils.Typing(ctx.client, ctx.room.room_id):\nawait ctx.respond(\"Pong!\")\nbot.run(...)\n</code></pre> <p>This will not work because <code>Context.respond</code> calls <code>NioBot.send_message</code>, and <code>NioBot.send_message</code> creates its own <code>Typing</code> instance. Once <code>ctx.respond</code> returns, the internal <code>Typing</code> instance is destroyed, and the typing event is stopped, as is the behaviour of exiting the context manager. This means that either if on the loop, the upper-most <code>utils.Typing</code> instance will simply just create a new typing notification, or will not (especially if <code>persistent</code> was set to <code>False</code>). This breaks the whole persistence of typing.</p> If you want to use <code>Typing</code> to show that you're processing something: <p>If you want to use <code>Typing</code> to show a user that your bot is \"thinking\", or similar, you should make sure you exit the instance before responding. For example:</p> <pre><code>from niobot import NioBot, Typing\nimport httpx\nbot = NioBot(...)\n@bot.command()\nasync def process(ctx):\n\"\"\"Spends a worryingly long time making a network request.\"\"\"\nasync with Typing(ctx.client, ctx.room.room_id):\nawait httpx.get(\"https://example.com\")\nawait ctx.respond(\"Done!\")\n</code></pre> <p>Be aware that this will cause a momentary blip in the <code>xyz is typing</code> status, but this is unavoidable, simply due to the semi-stateless nature of this context wrapper</p> <p>A potential future solution would be to implement some funky internal lock mechanism and/or just prevent nested <code>Typing</code> instances, but this is not a priority at the moment.</p>"},{"location":"reference/utils/typing/#niobot.utils.typing.Typing.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Starts the typing notification loop, or sends a single typing notification if not persistent.</p>"},{"location":"reference/utils/typing/#niobot.utils.typing.Typing.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc, tb)\n</code></pre> <p>Cancels any existing typing loop under this instance and sends a typing notification to stop typing.</p>"},{"location":"reference/utils/unblock/","title":"Unblock","text":"<p>A common problem developers encounter when working with an asyncio event loop is long blocking code. This can be caused by a number of things, but the most common is a call to a library that is not async-aware, and has many blocking operations (such as <code>requests</code>, or even the built-in <code>open()</code> + <code>read()</code> functions).</p> <p>To alleviate this, NioBot provides an \"unblock\" utility, which is a simple async function that will run any blocking code in the event loop executor, and returns the result, without pausing the event loop. This is equivalent to <code>loop.run_in_executor(None, func, *args, **kwargs)</code>.</p> A good example <p><pre><code>from niobot import NioBot, command\nfrom niobot.utils import run_blocking\nbot = NioBot(...)\n@bot.command(name=\"read\")\nasync def read_file(ctx: Context, filename: str):\nwith open(filename, \"r\") as f:\ncontents = await run_blocking(f.read)\nawait ctx.respond(contents)\nbot.run(...)\n</code></pre> This will read the contents of a file, without blocking the event loop, unlike the following code:</p> A bad example <p><pre><code>    from niobot import NioBot, command\nfrom niobot.utils import run_blocking\nbot = NioBot(...)\n@bot.command(name=\"read\")\nasync def read_file(ctx: Context, filename: str):\nwith open(filename, \"r\") as f:\ncontents = f.read()\nawait ctx.respond(contents)\nbot.run(...)\n</code></pre> This example is bad because it will prevent any other event processing until <code>f.read()</code> finishes, which is really bad if the file is large, or the disk is slow. For example, if you read at 1mb/s, and you have a 10 megabyte file, you will block the event loop for approximately 10 seconds, which means your program cannot do anything in those ten seconds, and as such your bot will appear to be non-functional!</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.run_blocking","title":"run_blocking  <code>async</code>","text":"<pre><code>run_blocking(\nfunction: typing.Callable, *args: Any, **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Takes a blocking function and runs it in a thread, returning the result.</p> <p>You should use this for any long-running functions that may take a long time to respond that are not coroutines that you can await. For example, running a subprocess.</p> Example <pre><code>import asyncio\nimport subprocess\nfrom niobot.utils import run_blocking\nasync def main():\nresult = await run_blocking(subprocess.run, [\"find\", \"*.py\", \"-type\", \"f\"], capture_output=True)\nprint(result)\nasyncio.run(main())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>typing.Callable</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function.</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.force_await","title":"force_await  <code>async</code>","text":"<pre><code>force_await(\nfunction: typing.Union[\ntyping.Callable, typing.Coroutine\n],\n*args: Any,\n**kwargs: Any\n)\n</code></pre> <p>Takes a function, and if it needs awaiting, it will be awaited. If it is a synchronous function, it runs it in the event loop, preventing it from blocking.</p> <p>This is equivalent to (pseudo): <pre><code>if can_await(x):\nawait x\nelse:\nawait run_blocking(x)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>typing.Union[typing.Callable, typing.Coroutine]</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the function.</p>"}]}