{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Welcome to the Nio-Bot Documentation</p>"},{"location":"#what-is-niobot","title":"What is NioBot?","text":"<p>NioBot (also referred to as nio-bot, or niobot) is a python library built on the  matrix-nio matrix sdk library (guess where we got our name from), which builds on an already powerful, extensive framework, to provide a super simple, easy-to-use matrix bot client.</p> <p>Traditionally, making bots with <code>matrix-nio</code> isn't massively difficult - it was just time consuming, with a lot of boiler plate, and often times a rushed lack of redundancy. In turn, making your own bot in base nio would end up with you making your own little in-house specialised framework, which not only is a lot of work to make and maintain, but usually ends up not being very flexible.</p> <p>NioBot aims to solve this problem by providing a framework that is both easy to use, and flexible enough to be used in a variety of situations.</p> <p>Also, Matrix and Matrix clients can be daunting to new users, and NioBot aims to make it easier for new users to get into Matrix, and to make it easier for them to make their own bots.</p> Creation background and motivations <p>I (nex) personally come from a discord bot development background, and am used to using discord.py (now py-cord), and jumping over to matrix gave me a strong whiplash feeling. In fact, it felt so different that I gave up twice making bots. This is actually my second public matrix bot framework, with the predecessor being called <code>matrix.py</code> (which is no longer available, and was never really finished).</p> <p>I decided to make this framework because I wanted to be able to have a single central framework that I could use for automating my account and also making some bots in, and thus NioBot was born.</p> <p>NioBot actually first started off as a fork of my now dead in-house framework I made ad-hoc for a bot at the time, borrowing a lot of code from it. However, as time has gone on, I've added so much more, including encryption support, images, and more.</p> <p>NioBot is designed to have a similar feel to <code>py-cord</code>, while still being true to the `matrix-nio`` library.</p> <p>As a matter of fact, I've personally contributed to both <code>py-cord</code> and <code>matrix-nio</code>, so you can rest assured that I know how both of these libraries work, and can get the most out of their feature set.</p> <p>Interested? Carry on reading!</p>"},{"location":"#features","title":"Features","text":"<ul> <li>A powerful commands framework (Modules, aliases, checks, easy extensibility)</li> <li>A flexible event system</li> <li>Simple end-to-end encryption</li> <li>Automatic markdown rendering when sending/editing messages</li> <li>Super simple to use Attachments system</li> <li>Very customisable monolithic client instance</li> <li>A simple, easy-to-use CLI tool for some on-the-go tasks</li> <li>And more to come</li> </ul>"},{"location":"#support","title":"Support","text":"<p>You can join our Matrix room for support if  you are unable to find your answer in these docs.</p> <p>Don't forget to look at the guides!</p>"},{"location":"#installing","title":"Installing","text":""},{"location":"#from-pypi","title":"From PyPi","text":"<p>The package is nio-bot, and can be installed with <code>pip install nio-bot[e2ee,cli]</code>.</p>"},{"location":"#from-github-releases","title":"From github releases","text":"<p>If you are unable to use PyPi for whatever reason, python wheels and source distributions are available in all github releases.</p> <p>Just go to the releases page, and download the latest release.</p> <p>You can then <code>pip install &lt;wheel file&gt;</code>.</p>"},{"location":"#from-source","title":"From source","text":"<p>If you want to get bleeding edge features, or simply build from source, you can use git. For example:</p> <pre><code>pip install git+https://github.com/EEKIM10/niobot.git@master#egg=niobot[e2ee,cli]\n</code></pre> <p>(replace @master with @branch-name or @tag-name for a specific branch or tag.)</p>"},{"location":"#cli","title":"CLI","text":"<p>The <code>niobot</code> package comes with a CLI tool, which can be used to create templates, get access tokens, resolve homeservers, and more (in the future).</p> <p>You can install the cli tool with the <code>cli</code> extra. The command itself is <code>niocli</code>.</p>"},{"location":"#version-information","title":"Version information","text":"<p>Version information is found in the <code>__version__.py</code> file, which is created while installing the package.</p> <pre><code>from niobot.__version__ import __version__\nprint(__version__)\n</code></pre>"},{"location":"#logging","title":"Logging","text":"<p>Logging is done using the <code>logging</code> module. The logger is named <code>niobot.&lt;module&gt;</code>. For example:</p> <pre><code>import logging\nimport niobot\nlogging.basicConfig(level=logging.INFO)\nbot = niobot.NioBot(...)\nbot.run(...)\n</code></pre> <p>This will now output a bunch of logs to your console, which you can use to debug your bot.</p>"},{"location":"guides/getting-started/","title":"Getting started / quick start","text":"<p>Unfinished guide</p> <p>This guide is not yet finished.</p> <p>So, you've joined matrix, had a look around, and now you want to make your own little bot? Guess what, you can do just that with nio-bot!</p>"},{"location":"guides/getting-started/#prerequisites","title":"Prerequisites","text":"<p>You will need the following in general:</p> <ul> <li>A matrix account you can log into (username and password initially)</li> </ul> <p>And the following installed on the machine you want to run the bot on:</p> <ul> <li>Python 3.11 or higher with sqlite support</li> <li><code>libolm</code> (use your system package manager, like apt or pacman) in order to use end-to-end encryption.</li> <li>A decent network connection (at least a few megabits a second, preferably more)</li> <li>At least 100mb free storage space (for the database and other files)</li> </ul>"},{"location":"guides/getting-started/#installation","title":"Installation","text":"<p>After you've installed and acquired the above, you can install nio-bot with the following command: <pre><code>python3 -m pip install git+https://github.com/EEKIM10/nio-bot.git#egg=nio-bot[cli]\n# Note that we install the extras for `cli` here - the niobot CLI comes with a bunch of useful tools we'll use.\n</code></pre> If you would like to install support for end-to-end encryption, you can install the following instead: <pre><code>python3 -m pip install git+https://github.com/EEKIM10/nio-bot.git#egg=nio-bot[cli,e2ee]\n</code></pre></p> <p>After you've done that, verify everything installed fine by running <code>niocli version</code>: <pre><code>(venv) [me@host test-niobot]$ niocli version\nNioBot version: 0.1.dev115+g5af233e (Version 0.1, build dev115, commit '5af233e', built '04/07/230')\nmatrix-nio version: 0.20.2\nPython version: 3.11.3\nPython implementation: CPython\nOperating System: Linux-6.4.1-arch1-1-x86_64-with-glibc2.37\nArchitecture: x86_64\nOLM Installed: Yes\n</code></pre></p> <p>Info</p> <p>Yes, this output is long and verbose. It is intentionally long and verbose in order to provide as much information as possible for bug reports. All you need to do is make sure there aren't too many red flags.</p> <p>For example, if you want end to end encryption, but <code>OLM Installed</code> is a red <code>No</code>, then you need to install <code>libolm</code>.</p> My architecture is red! <p>You will notice any sort of other architecture outside of <code>x86_64</code> is red - this does not mean that nio-bot won't work! Currently, nio-bot is mainly developed on an AMD64 architecture, so support is only officially for that arch. However, several people have run nio-bot on ARM64 (raspberry pi, at least), and it works fine.</p> <p>You can safely ignore this warning if you are running on a different architecture.</p> <p>If anything else is red though, you should look into it.</p>"},{"location":"guides/getting-started/#creating-the-start-of-your-bot","title":"Creating the start of your bot","text":"<p>In our instance here, we'll create a few files:</p> <ol> <li>A <code>config.py</code> file to store our configuration.</li> <li>A <code>main.py</code> file to store our bot code.</li> <li>A <code>fun.py</code> file to store a module (later on).</li> </ol> <p>And you'll need a directory:</p> <ol> <li><code>store</code> - this is where nio-bot will store its database and other files.</li> </ol>"},{"location":"guides/getting-started/#file-structure","title":"File structure","text":"<p>And as such, our directory structure will look like this: <pre><code>test-niobot/\n\u251c\u2500\u2500 config.py\n\u251c\u2500\u2500 fun.py\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 store/\n\u2514\u2500\u2500 main.py\n</code></pre></p> <p>Danger</p> <p>Make sure, if you are using version control, to add <code>config.py</code> to your <code>.gitignore</code> file! This file contains all of your personal information, such as your password, and should not be shared with anyone.</p> <p>While you're at it, you should add the <code>store</code> directory to your <code>.gitignore</code> file as well, as that will contain encryption keys later on.</p>"},{"location":"guides/getting-started/#setting-up-configpy","title":"Setting up config.py","text":"<p>In our <code>config.py</code> file, we'll add the following: <pre><code>HOMESERVER = \"https://matrix.org\"\nUSER_ID = \"@my-username:matrix.org\"\nPASSWORD = \"my-password\"\n</code></pre></p> <p>Warning</p> <p>Make sure to replace the above with your own homeserver, user ID, and password!</p>"},{"location":"guides/getting-started/#making-the-bot-runtime-file","title":"Making the bot runtime file","text":"<p>And, to make a simple bot, you can just copy the below template into your <code>main.py</code> file: <pre><code>import niobot\nimport config\nbot = niobot.NioBot(\nhomeserver=config.HOMESERVER,\nuser_id=config.USER_ID,\ndevice_id='my-device-id',\nstore_path='./store',\ncommand_prefix=\"!\",\nowner_id=\"@my-matrix-username:matrix.org\"\n)\n# We also want to load `fun.py`'s commands before starting:\nbot.mount_module(\"fun\")  # looks at ./fun.py\n@bot.on_event(\"ready\")\nasync def on_ready(_):\n# That first argument is needed as the first result of the sync loop is passed to ready. Without it, this event\n# will fail to fire, and will cause a potentially catasrophic failure.\nprint(\"Bot is ready!\")\n@bot.command()\nasync def ping(ctx):  # can be invoked with \"!ping\"\nawait ctx.reply(\"Pong!\")\nbot.run(password=config.PASSWORD)\n</code></pre></p> About <code>owner_id</code> <p><code>owner_id</code> is intended to tell nio-bot who owns the current instance. Do not set this to be the same thing as <code>config.USER_ID</code> (your bot's ID)! The only time you should do that is if you want to run the bot on the same account you use.</p> <p>Otherwise, set this to be your own user ID, so that you can use any \"owner only\" commands.</p> <p>It is not necessary to set this though, so it can be omitted or set to <code>None</code>. Just note that <code>NioBot.is_owner(...)</code> will raise an error when used.</p>"},{"location":"guides/getting-started/#enabling-logging","title":"Enabling logging","text":"<p>You'll probably find that it's useful to enable debug logging while you're developing your bot. To do that, you can add the following to your <code>main.py</code> file: <pre><code>import logging\nimport niobot\nlogging.basicConfig(level=logging.DEBUG)\n# or to save to a file (uncomment):\n# logging.basicConfig(level=logging.DEBUG, filename=\"bot.log\")\nbot = niobot.NioBot(...)\n...\n</code></pre></p>"},{"location":"guides/getting-started/#making-funpy","title":"Making fun.py","text":"<p>Now, fun.py is going to be a module.</p> <p>Modules are a great way to organize your code, and make it easier to manage. They also allow you to easily add new commands to your bot without having to edit the main file, which means you can split your code up, and make it... modular!</p> <p>To start, we need to make the fun.py python file, and add the following: <pre><code>import niobot\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\ndef __init__(self, bot):\nself.bot = bot  # bot is the NioBot instance you made in main.py!\n</code></pre> And that's it! You made your module!</p>"},{"location":"guides/getting-started/#but-wait-theres-more","title":"But wait, there's more!","text":"<p>You may notice that with this being a separate module, you can't use <code>@bot.command</code>, or <code>@bot.on_event</code>, or reference <code>bot</code> at all!</p> <p>You'd initially assume \"Oh, I'll just import bot from main.\" - but that's not going to work. The reason for this is every time <code>main.py</code> is imported, it creates a new <code>NioBot</code>, and then... calls bot.run() at the end, meaning not only would your import never finish, but it would also cause a massive recursion bug!</p> <p>The way you get around this is instead with <code>@niobot.command()</code>. This is a decorator that will register the command with the bot, however is designed specifically with modules in mind.</p> <p>Let's compare the two, for simplicity:</p> <code>@niobot.NioBot.command()</code> <code>@niobot.command()</code> Adds commands to the register immediately Adds commands to the register once the module is loaded Can only be used at runtime, or wherever <code>bot</code> can be imported from Can only be used in modules (has no effect outside a<code>niobot.Module</code>!) Takes priority over <code>@niobot.command()</code> due to the immediate register Lower priority than <code>NioBot.command()</code> due to the \"lazy loading\" <p>Do be aware though, both decorators will take the exact same arguments as <code>niobot.Command</code>.</p>"},{"location":"guides/getting-started/#adding-a-command-to-funpy","title":"Adding a command to fun.py","text":"<p>So, let's add a command to our module: <pre><code>import niobot\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\ndef __init__(self, bot):\nself.bot = bot  # bot is the NioBot instance you made in main.py!\n@niobot.command()\nasync def hello(self, ctx):\nawait ctx.reply(\"Hello %s!\" % ctx.event.sender)\n</code></pre> This will add a command, <code>!hello</code>, that will reply with \"Hello {@author}!\"</p>"},{"location":"guides/getting-started/#starting-the-bot","title":"Starting the bot","text":"<p>Hold your horses, you're not quite ready yet!</p> <p>Generally, it's a terrible idea to always use a password in your code. It's a security risk, and in matrix it can result in creating many sessions, which you don't want, especially if you're using encryption!</p>"},{"location":"guides/getting-started/#getting-an-access-token","title":"Getting an access token","text":"<p>An access token is like a server-generated long-lived password. You will probably want one in order to repeatedly use the same session, and to avoid having to use your password in your code.</p> <p>You can get your password with <code>niocli get-access-token</code>. For example: <pre><code>(venv) [me@host test-niobot]$ niocli get-access-token\nUser ID (@username:homeserver.tld): @test:matrix.org\nPassword (will not echo): Device ID (a memorable display name for this login, such as 'bot-production') [host]: Resolving homeserver... OK\nGetting access token... OK\nAccess token: syt_&lt;...&gt;\n</code></pre></p> <p>What you're going to do now, is copy the full access token string, and open <code>config.py</code> again Now, replace <code>PASSWORD=...</code> with <code>ACCESS_TOKEN=\"syt_&lt;...&gt;\"</code>. Make sure to keep the quotes!</p> <p>You will also need to go into <code>main.py</code>, down to the last line, and replace <code>password=config.PASSWORD</code> with <code>access_token=config.ACCESS_TOKEN</code>.</p> What is <code>sso_token</code>? <p>SSO token is a <code>S</code>ingle <code>S</code>ign <code>O</code>n token, employed by the likes of Mozilla, and is often used for SAML. Chances are, if you don't know what it is, you definitely don't need it. And if you do need it, you already know what it is, why you need it, and how to get it.</p>"},{"location":"guides/getting-started/#actually-running-the-bot","title":"Actually running the bot","text":"<p>This is the really simple part, actually. All you need to do now is run <code>main.py</code>!</p> <pre><code>(venv) [me@host test-niobot]$ python main.py\n&lt;insert log spam here&gt;\nBot is ready!\n&lt;insert log spam here&gt;\n</code></pre> <p>Its taking FOREVER to log in! is something going wrong?</p> <p>Nope. It can often take a while (upwards of five minutes in some cases!) for the bot to log in. This is because, when you first start the bot, it has to sync your entire state with the server. This often results in a LOT of IO, and a lot of network waiting, etc.</p> <p>You can speed up this process in the future by:</p> <ul> <li>Making sure you have <code>store_path</code> and a valid store in your configuration. Stores mean that the bot doesn't have   to re-sync everything every time it starts up.</li> <li>Using an access token instead of a password. This means that the bot doesn't have to log in, and can just start   syncing immediately, even from the last time it was stopped, which saves a very very large portion of the time   taken</li> </ul>"},{"location":"guides/getting-started/#interesting-log-output","title":"Interesting log output","text":"<p>You may notice that, if you enabled logging, you get some interesting log output.</p> <p>Some things you will want to keep an eye out for:</p> <ul> <li><code>INFO:niobot.client:Encryption support enabled automatically.</code> - This means that you have set up requirements for the   bot to use encryption, and it has detected that it can use encryption, and automatically enabled it, which is good!</li> <li><code>DEBUG:niobot.client:&lt;module '...' from '...'&gt; does not have its own setup() - auto-discovering commands and events</code> - This   means that the bot has detected a module, and is automatically loading it. This is good for most cases.   You should only worry about this message if you defined your own setup function.</li> <li><code>DEBUG:niobot.client:Registered command &lt;Command name='...' aliases=[...] disabled=...&gt; into &lt;command_name&gt;</code> - This simply   means a command has been added to the internal register.</li> <li><code>DEBUG:niobot.client:Added event listener &lt;function &lt;function_name&gt; at &lt;address&gt;&gt; for '&lt;event_name&gt;'</code> - Like the above,   this simply means an event has been added to the internal register.</li> </ul>"},{"location":"guides/getting-started/#and-thats-it","title":"And that's it!","text":"<p>You've successfully made a bot, and got it running!</p>"},{"location":"guides/getting-started/#wait-how-do-i-use-it","title":"Wait, how do I use it?","text":"<p>nio-bot has a handy dandy auto-join feature - if you just invite your bot's user to a room, assuming all is correct, within a couple seconds, your bot will automatically join your room!</p> <p>Then, you can run <code>!help</code> to get a list of commands, and <code>!help &lt;command&gt;</code> to get help on a specific command.</p>"},{"location":"guides/getting-started/#final-product","title":"Final product","text":"config.py <pre><code>HOMESERVER = \"https://matrix.org\"  # or your homeserver\nUSER_ID = \"@my-bot:matrix.org\"  # your bot account's user ID\nACCESS_TOKEN = \"syt_&lt;...&gt;\"  # your bot account's access token\n</code></pre> main.py <pre><code>import niobot\nimport logging\nimport config\nlogging.basicConfig(level=logging.INFO, filename=\"bot.log\")\nbot = niobot.NioBot(\nhomeserver=config.HOMESERVER,\nuser_id=config.USER_ID,\ndevice_id='my-device-id',\nstore_path='./store',\ncommand_prefix=\"!\",\nowner_id=\"@my-matrix-username:matrix.org\"\n)\n# We also want to load `fun.py`'s commands before starting:\nbot.mount_module(\"fun\")\n@bot.on_event(\"ready\")\nasync def on_ready(_):\n# That first argument is needed as the first result of the sync loop is passed to ready. Without it, this event\n# will fail to fire, and will cause a potentially catasrophic failure.\nprint(\"Bot is ready!\")\n@bot.command()\nasync def ping(ctx):  # can be invoked with \"!ping\"\nawait ctx.reply(\"Pong!\")\nbot.run(access_token=config.ACCESS_TOKEN)\n</code></pre> fun.py <pre><code>import niobot\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\ndef __init__(self, bot):\nself.bot = bot  # bot is the NioBot instance you made in main.py!\n@niobot.command()\nasync def hello(self, ctx):\nawait ctx.reply(\"Hello %s!\" % ctx.event.sender)\n</code></pre>"},{"location":"guides/sending-attachments/","title":"Sending attachments","text":"<p>Sometimes, you want to upload attachments in your chat. Be that images, videos, or other kinds of files. NioBot supports this, and it's very easy to do.</p>"},{"location":"guides/sending-attachments/#before-you-start","title":"Before you start","text":"<p>In order to use the majority of the features in this guide, you will need to install <code>ffmpeg</code> and <code>imagemagick</code>. These are used for thumbnail generation, and metadata detection.</p> <p>You should use your package manager to install these, as they are not python packages.</p> Debian/UbuntuArchFedoramacOSWindows <pre><code>sudo apt install ffmpeg imagemagick\n</code></pre> <pre><code>sudo pacman -S ffmpeg imagemagick\n</code></pre> <pre><code>sudo dnf install ffmpeg imagemagick\n</code></pre> <pre><code>brew install ffmpeg imagemagick\n</code></pre> <p><pre><code>choco install ffmpeg\nchoco install imagemagick\n</code></pre> Or, install it yourself. Make sure the binaries are in your PATH:</p> <ul> <li>gyan.dev/ffmpeg/builds/ffmpeg-git-essentials.7z</li> <li>imagemagick.org/script/download.php</li> </ul>"},{"location":"guides/sending-attachments/#faq","title":"FAQ","text":"Why do I need to install <code>ffmpeg</code> and <code>imagemagick</code>? <p><code>imagemagick</code> is actually optional - if you trust <code>ffprobe</code> to work with all of your images (in some cases it can fail to detect newer image formats), then you can skip installing it.</p> <p>However, <code>ffmpeg</code> is required for all but file attachments. This is because in order to get some rich data, such as dimensions and duration, we need to use <code>ffprobe</code> to get this data. Furthermore, in the event <code>imagemagick</code> is not installed, the metadata fetcher falls back to <code>ffprobe</code>.</p> <p>Not having these installed will result in a <code>RuntimeError</code> being raised when you try to send an attachment when it tries to fetch metadata. This is because the metadata fetcher will not be able to find <code>ffprobe</code> or <code>imagemagick</code> in your PATH.</p> Why does it take a couple of seconds for <code>&lt;attachment&gt;.from_file()</code> to return? <p>The <code>from_file</code> method (see: niobot.VideoAttachment.from_file, niobot.ImageAttachment.from_file, etc.)  does a lot of heavy lifting in terms of preparing a file with all the bells and whistles for an upload.  This means that it has to do a lot of processing, which may take a couple of seconds to return.</p>"},{"location":"guides/sending-attachments/#sending","title":"Sending:","text":""},{"location":"guides/sending-attachments/#regular-files","title":"Regular files","text":"<p>Here, regular files can be anything that isn't a video, image, or audio file. This includes text files, PDFs, etc. You can even send binary or pre-encrypted (why?) files if you want to.</p> <p>Regular files are the simplest file type in niobot, in terms of code complexity and also features. Regular files do not support:</p> <ul> <li>Thumbnails</li> <li>Rich data</li> <li>Previews</li> </ul> <p>All you get from thumbnails is the file name, and the file size. That's it.</p> <p>Anyway, here's how you could send an example text (foo.txt) file: <pre><code>from niobot import NioBot, Context, FileAttachment\nfrom pathlib import Path\n...\n@bot.comand(name=\"upload.txt\")\nasync def upload_txt(ctx: Context):\n\"\"\"Sends a text file!\"\"\"\nawait ctx.respond(file=attachment)\n</code></pre></p> <p>This results in the following: </p> <p>You can then click on the file to download it!</p>"},{"location":"guides/sending-attachments/#images","title":"Images","text":"<p>Images are a bit more complex than regular files. They support thumbnails, rich data, and previews.</p> Thumbnails for images <p>While you may think that thumbnails for images are useless, they are actually very useful for clients. Just beware though, having a larger or equal size image for your thumbnail is very counter productive.</p> <p>A valid use case for image thumbnails is for lower-resolution, likely compressed versions of the image you're sending. Paired with a blurhash, this can provide a very good \"placeholder\" image for people on  painfully slow connections.</p> <p>For your convenience, unless disabled, niobot will automatically generate a \"blurhash\" for your image.</p> <p>A blurhash is very good for providing a \"placeholder\" image, as it is generated by a string of around 30 characters. This means people on super slow connections can see a pretty preview of the image (without much detail), instead of having an ugly loading spinner or outright blank space in place of a loading image.</p> <p>For example:</p> <p> </p> This may slow down your image upload <p>Generating blurhashes, especially for large images, even more especially with a weak CPU, can be very slow. While this will not block your code execution, it means you must wait for the blurhash to be generated before you can do anything with the image.</p> <p>You may want to disable this behaviour. See disabling extra media features.</p> <p>And here's an example: <pre><code>from niobot import NioBot, Context, ImageAttachment\nfrom pathlib import Path\n...\n@bot.comand(name=\"upload.png\")\nasync def upload_png(ctx: Context):\n\"\"\"Sends a png image!\"\"\"\nattachment = await ImageAttachment.from_file(\"file.png\")\nawait ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/sending-attachments/#audio","title":"Audio","text":"<p>Audio files are actually simpler than images, however they do not support thumbnails or rich data outside of their duration.</p> Beware your codec! <p>You should aim to have your audio files as <code>opus</code>, <code>vorbis</code>, <code>aac</code>, <code>flac</code>, or <code>mp3</code> encoded files, as some clients may not be able to play other formats. Also be mindful of their containers, since some (such as <code>mkv</code>) won't play in some clients.</p> <p>Here's an example: <pre><code>from niobot import NioBot, Context, AudioAttachment\nfrom pathlib import Path\n...\n@bot.comand(name=\"upload.mp3\")\nasync def upload_mp3(ctx: Context):\n\"\"\"Sends a mp3 audio file!\"\"\"\nattachment = await AudioAttachment.from_file(\"file.mp3\")\nawait ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/sending-attachments/#videos","title":"Videos","text":"<p>Videos are the most complex file type in niobot. They support thumbnails, rich data, and previews.</p> <p>Again though, NioBot makes this easy. All you need to do is pass a video file to <code>VideoAttachment.from_file()</code>.</p> <p>The same warnings apply as images, except for the blurhash. Blurhashes are not generated for videos. However, thumbnails are generated by default, with their own blurhashes. For simplicity, the video's auto-generated thumbnail is simply the first frame of the video.</p> <p>Beware of your codec(s)!</p> <p>A lot of matrix clients at the moment are simple HTML5-based clients - meaning they can only play a limited set of codecs out of the box.</p> <p>You should aim to keep your video codecs as <code>h264</code>, <code>vp8</code>, or <code>vp9</code>, as these are the most widely supported. However, some native apps may not even support vp8/vp9. Use h264/avc when in doubt.</p> <p>Look at audio's warning for more information about audio codecs.</p> <p>Here's an example: <pre><code>from niobot import NioBot, Context, VideoAttachment\nfrom pathlib import Path\n...\n@bot.comand(name=\"upload.mp4\")\nasync def upload_mp4(ctx: Context):\n\"\"\"Sends a mp4 video!\"\"\"\nattachment = await VideoAttachment.from_file(\"file.mp4\")\nawait ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/sending-attachments/#disabling-extra-media-features","title":"Disabling extra media features","text":""},{"location":"guides/sending-attachments/#disabling-blurhash-generation","title":"Disabling blurhash generation","text":"This will harm the user experience <p>Disabling blurhash generation is a terrible idea - unless you make sure your uploads are a matter of kilobytes, you will always see blank spots while at least a thumbnail is loaded. Please consider alternative options.</p> <p>for niobot.VideoAttachment and niobot.ImageAttachment: <pre><code>from niobot import NioBot, Context, ImageAttachment, VideoAttachment\n...\nasync def foo():\nattachment = await ImageAttachment.from_file(\"file.png\", generate_blurhash=False)\n# or for Videos\nattachment = await VideoAttachment.from_file(\"file.mp4\", generate_blurhash=False)\n</code></pre></p>"},{"location":"guides/sending-attachments/#disabling-thumbnail-generation","title":"Disabling thumbnail generation","text":"This will harm the user experience <p>If you intend to disable thumbnail generation, you should provide your own thumbnail, or at the very least leave blurhash generation enabled.</p> <p>Otherwise, while your video loads, clients will most likely just show a completely transparent box, with a loading spinner at a stretch. This leaves a massive chunk of the UI completely blank while your video loads.</p> <p>for niobot.VideoAttachment only: <pre><code>from niobot import NioBot, Context, ImageAttachment, VideoAttachment\n...\nasync def foo():\nattachment = await VideoAttachment.from_file(\"file.mp4\", thumbnail=False)\n</code></pre></p>"},{"location":"guides/sending-attachments/#disabling-rich-data","title":"Disabling rich data","text":"<p>A lot of rich data fields will still require values for clients to properly render the media!</p> <p>In this case, \"rich data\" refers to some \"optional\" fields in media uploads, such as <code>height</code>, <code>width</code>, <code>duration</code>, etc. These fields are not required for the server to accept the upload, but they are often used by clients to figure out how to properly display the media.</p> <p>\"Rich data\" is gathered from the get_metadata function, which itself calls <code>ffprobe</code>/imagemagick as a subprocess. If, for whatever reason, this is undesirable, you can avoid it.</p> <p>Disabling rich data is not 100% possible, but you can avoid it by passing minimal values where it would automatically be filled in:</p>"},{"location":"guides/sending-attachments/#images_1","title":"Images","text":"<pre><code>from niobot import ImageAttachment\nasync def foo():\nattachment = await ImageAttachment.from_file(\"file.png\", width=0, height=0, unsafe=True)\n</code></pre>"},{"location":"guides/sending-attachments/#videos_1","title":"Videos","text":"<p><pre><code>from niobot import VideoAttachment\nasync def foo():\nattachment = await VideoAttachment.from_file(\"file.mp4\", width=0, height=0, duration=0)\n</code></pre> You may also want to consider either manually passing a thumbnail, or disabling thumbnail auto generation, as otherwise you'll still have ffmpeg/imagemagick called.</p>"},{"location":"guides/sending-attachments/#audio_1","title":"Audio","text":"<pre><code>from niobot import AudioAttachment\nasync def foo():\nattachment = await AudioAttachment.from_file(\"file.mp3\", duration=0)\n</code></pre>"},{"location":"reference/attachment/","title":"Attachments","text":"<p>Matrix file attachments. Full e2ee support is implemented.</p>"},{"location":"reference/attachment/#niobot.attachment.AttachmentType","title":"AttachmentType","text":"<p>             Bases: <code>enum.Enum</code></p> <p>Enumeration containing the different types of media.</p> <p>Attributes:</p> Name Type Description <code>FILE</code> <code>AttachmentType</code> <p>A generic file.</p> <code>AUDIO</code> <code>AttachmentType</code> <p>An audio file.</p> <code>VIDEO</code> <code>AttachmentType</code> <p>A video file.</p> <code>IMAGE</code> <code>AttachmentType</code> <p>An image file.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment","title":"BaseAttachment","text":"<p>             Bases: <code>abc.ABC</code></p> <p>Base class for attachments</p> <p>Note</p> <p>If you pass a custom <code>file_name</code>, this is only actually used if you pass a io.BytesIO to <code>file</code>. If you pass a pathlib.Path or a string, the file name will be resolved from the path, overriding the <code>file_name</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file path or BytesIO object to upload.</p> required <code>file_name</code> <code>str</code> <p>The name of the file. Must be specified if uploading a BytesIO object.</p> <code>None</code> <code>mime_type</code> <code>str</code> <p>The mime type of the file. If not specified, it will be detected.</p> <code>None</code> <code>size_bytes</code> <code>int</code> <p>The size of the file in bytes. If not specified, it will be detected.</p> <code>None</code> <code>attachment_type</code> <code>AttachmentType</code> <p>The type of attachment. Defaults to <code>AttachmentType.FILE</code>.</p> <code>AttachmentType.FILE</code> <p>Attributes:</p> Name Type Description <code>file</code> <code>typing.Union[pathlib.Path, io.BytesIO]</code> <p>The file path or BytesIO object to upload. Resolved to a pathlib.Path object if a string is passed to <code>__init__</code>.</p> <code>file_name</code> <code>str</code> <p>The name of the file. If <code>file</code> was a string or <code>Path</code>, this will be the name of the file.</p> <code>mime_type</code> <code>str</code> <p>The mime type of the file.</p> <code>size</code> <code>int</code> <p>The size of the file in bytes.</p> <code>type</code> <code>AttachmentType</code> <p>The type of attachment.</p> <code>url</code> <code>str | None</code> <p>The URL of the uploaded file. This is set after the file is uploaded.</p> <code>keys</code> <code>typing.Dict[str, str] | None</code> <p>The encryption keys for the file. This is set after the file is uploaded.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.size_bytes","title":"size_bytes  <code>property</code>","text":"<pre><code>size_bytes: int\n</code></pre> <p>Returns the size of this attachment in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.as_body","title":"as_body","text":"<pre><code>as_body(body: str = None) -&gt; dict\n</code></pre> <p>Generates the body for the attachment for sending. The attachment must've been uploaded first.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The body to use (should be a textual description). Defaults to the file name.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\nfile: typing.Union[str, io.BytesIO, pathlib.Path],\nfile_name: str = None,\n) -&gt; BaseAttachment\n</code></pre> <p>Creates an attachment from a file.</p> <p>You should use this method instead of the constructor, as it will automatically detect all other values</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file or BytesIO to attach</p> required <code>file_name</code> <code>str</code> <p>The name of the BytesIO file, if applicable</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>Loaded attachment.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.size_as","title":"size_as","text":"<pre><code>size_as(\nunit: typing.Literal[\n\"b\", \"kb\", \"kib\", \"mb\", \"mib\", \"gb\", \"gib\"\n]\n) -&gt; typing.Union[int, float]\n</code></pre> <p>Helper function to convert the size of this attachment into a different unit.</p> Example <p><pre><code>&gt;&gt;&gt; import niobot\n&gt;&gt;&gt; attachment = niobot.FileAttachment(\"test.txt\", \"text/plain\")\n&gt;&gt;&gt; attachment.size_bytes\n1024\n&gt;&gt;&gt; attachment.size_as(\"kb\")\n1.024\n&gt;&gt;&gt; attachment.size_as(\"mb\")\n0.001024\n</code></pre> Note that due to the nature of floats, precision may be lost, especially the larger in units you go.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>typing.Literal['b', 'kb', 'kib', 'mb', 'mib', 'gb', 'gib']</code> <p>The unit to convert into</p> required <p>Returns:</p> Type Description <code>typing.Union[int, float]</code> <p>The converted size</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(\nclient: NioBot, encrypted: bool = False\n) -&gt; BaseAttachment\n</code></pre> <p>Uploads the file to matrix.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The client to upload</p> required <code>encrypted</code> <code>bool</code> <p>Whether to encrypt the thumbnail or not</p> <code>False</code> <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>The attachment</p>"},{"location":"reference/attachment/#niobot.attachment.SupportXYZAmorganBlurHash","title":"SupportXYZAmorganBlurHash","text":"<p>             Bases: <code>BaseAttachment</code></p> <p>Represents an attachment that supports blurhashes.</p> <p>Parameters:</p> Name Type Description Default <code>xyz_amorgan_blurhash</code> <code>str</code> <p>The blurhash of the attachment</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>xyz_amorgan_blurhash</code> <code>str</code> <p>The blurhash of the attachment</p>"},{"location":"reference/attachment/#niobot.attachment.SupportXYZAmorganBlurHash.get_blurhash","title":"get_blurhash  <code>async</code>","text":"<pre><code>get_blurhash(quality: typing.Tuple[int, int] = 4, 3) -&gt; str\n</code></pre> <p>Gets the blurhash of the attachment. See: woltapp/blurhash</p> <p>Parameters:</p> Name Type Description Default <code>quality</code> <code>typing.Tuple[int, int]</code> <p>A tuple of the quality to generate the blurhash at. Defaults to (4, 3).</p> <code>4, 3</code> <p>Returns:</p> Type Description <code>str</code> <p>The blurhash</p>"},{"location":"reference/attachment/#niobot.attachment.FileAttachment","title":"FileAttachment","text":"<p>             Bases: <code>BaseAttachment</code></p> <p>Represents a generic file attachment.</p> <p>You should use VideoAttachment for videos, AudioAttachment for audio, and ImageAttachment for images. This is for everything else.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>str</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>str</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>int</code> <p>The size of the file in bytes</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment","title":"ImageAttachment","text":"<p>             Bases: <code>SupportXYZAmorganBlurHash</code></p> <p>Represents an image attachment.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>str</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>str</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>int</code> <p>The size of the file in bytes</p> <code>None</code> <code>height</code> <code>int</code> <p>The height of the image in pixels (e.g. 1080)</p> <code>None</code> <code>width</code> <code>int</code> <p>The width of the image in pixels (e.g. 1920)</p> <code>None</code> <code>thumbnail</code> <code>ImageAttachment</code> <p>A thumbnail of the image. NOT a blurhash.</p> <code>None</code> <code>xyz_amorgan_blurhash</code> <code>str</code> <p>The blurhash of the image</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>info</code> <p>A dict of info about the image. Contains <code>h</code>, <code>w</code>, <code>mimetype</code>, and <code>size</code> keys.</p> <code>thumbnail</code> <p>A thumbnail of the image. NOT a blurhash.</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\nfile: typing.Union[str, io.BytesIO, pathlib.Path],\nfile_name: str = None,\nheight: int = None,\nwidth: int = None,\nthumbnail: ImageAttachment = None,\ngenerate_blurhash: bool = True,\n*,\nunsafe: bool = False\n) -&gt; ImageAttachment\n</code></pre> <p>Generates an image attachment</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>str</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>height</code> <code>int</code> <p>The height, in pixels, of this image</p> <code>None</code> <code>width</code> <code>int</code> <p>The width, in pixels, of this image</p> <code>None</code> <code>thumbnail</code> <code>ImageAttachment</code> <p>A thumbnail for this image</p> <code>None</code> <code>generate_blurhash</code> <code>bool</code> <p>Whether to generate a blurhash for this image</p> <code>True</code> <code>unsafe</code> <code>bool</code> <p>Whether to allow uploading of images with unsupported codecs. May break metadata detection.</p> <code>False</code> <p>Returns:</p> Type Description <code>ImageAttachment</code> <p>An image attachment</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment","title":"VideoAttachment","text":"<p>             Bases: <code>BaseAttachment</code></p> <p>Represents a video attachment.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>str</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>str</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>int</code> <p>The size of the file in bytes</p> <code>None</code> <code>height</code> <code>int</code> <p>The height of the video in pixels (e.g. 1080)</p> <code>None</code> <code>width</code> <code>int</code> <p>The width of the video in pixels (e.g. 1920)</p> <code>None</code> <code>duration</code> <code>int</code> <p>The duration of the video in seconds</p> <code>None</code> <code>thumbnail</code> <code>ImageAttachment</code> <p>A thumbnail of the video. NOT a blurhash.</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\nfile: typing.Union[str, io.BytesIO, pathlib.Path],\nfile_name: str = None,\nduration: int = None,\nheight: int = None,\nwidth: int = None,\nthumbnail: ImageAttachment\n| typing.Literal[False] = None,\ngenerate_blurhash: bool = True,\n) -&gt; VideoAttachment\n</code></pre> <p>Generates a video attachment</p> <p>This function auto-generates a thumbnail!</p> <p>As thumbnails greatly improve user experience, even with blurhashes enabled, this function will by default create a thumbnail of the first frame of the given video if you do not provide one yourself. This may increase your initialisation time by a couple seconds, give or take!</p> <p>If this is undesirable, pass <code>thumbnail=False</code> to disable generating a thumbnail. This is independent of <code>generate_blurhash</code>.</p> <p>Generated thumbnails are always WebP images, so they will always be miniature, so you shouldn't notice a significant increase in upload time, especially considering your video will likely be several megabytes.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>str</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>duration</code> <code>int</code> <p>The duration of the video, in seconds</p> <code>None</code> <code>height</code> <code>int</code> <p>The height, in pixels, of this video</p> <code>None</code> <code>width</code> <code>int</code> <p>The width, in pixels, of this video</p> <code>None</code> <code>thumbnail</code> <code>ImageAttachment | typing.Literal[False]</code> <p>A thumbnail for this image</p> <code>None</code> <code>generate_blurhash</code> <code>bool</code> <p>Whether to generate a blurhash for this image</p> <code>True</code> <p>Returns:</p> Type Description <code>VideoAttachment</code> <p>An image attachment</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.generate_thumbnail","title":"generate_thumbnail  <code>async</code> <code>staticmethod</code>","text":"<pre><code>generate_thumbnail(\nvideo: typing.Union[str, pathlib.Path, VideoAttachment]\n) -&gt; ImageAttachment\n</code></pre> <p>Generates a thumbnail for a video.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>typing.Union[str, pathlib.Path, VideoAttachment]</code> <p>The video to generate a thumbnail for</p> required <p>Returns:</p> Type Description <code>ImageAttachment</code> <p>The path to the generated thumbnail</p>"},{"location":"reference/attachment/#niobot.attachment.AudioAttachment","title":"AudioAttachment","text":"<p>             Bases: <code>BaseAttachment</code></p> <p>Represents an audio attachment.</p>"},{"location":"reference/attachment/#niobot.attachment.AudioAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\nfile: typing.Union[str, io.BytesIO, pathlib.Path],\nfile_name: str = None,\nduration: int = None,\n) -&gt; AudioAttachment\n</code></pre> <p>Generates an audio attachment</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>str</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>duration</code> <code>int</code> <p>The duration of the audio, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>AudioAttachment</code> <p>An audio attachment</p>"},{"location":"reference/attachment/#niobot.attachment.detect_mime_type","title":"detect_mime_type","text":"<pre><code>detect_mime_type(\nfile: typing.Union[str, io.BytesIO, pathlib.Path]\n) -&gt; str\n</code></pre> <p>Detect the mime type of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, io.BytesIO, pathlib.Path]</code> <p>The file to detect the mime type of. Can be a BytesIO.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The mime type of the file (e.g. <code>text/plain</code>, <code>image/png</code>, <code>application/pdf</code>, <code>video/webp</code> etc.)</p>"},{"location":"reference/attachment/#niobot.attachment.get_metadata_ffmpeg","title":"get_metadata_ffmpeg","text":"<pre><code>get_metadata_ffmpeg(\nfile: typing.Union[str, pathlib.Path]\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>Gets metadata for a file via ffprobe.</p> <p>example output (JSON)</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, pathlib.Path]</code> <p>The file to get metadata for. Must be a path-like object</p> required <p>Returns:</p> Type Description <code>typing.Dict[str, typing.Any]</code> <p>A dictionary containing the metadata.</p>"},{"location":"reference/attachment/#niobot.attachment.get_metadata_imagemagick","title":"get_metadata_imagemagick","text":"<pre><code>get_metadata_imagemagick(\nfile: pathlib.Path,\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>The same as <code>get_metadata_ffmpeg</code> but for ImageMagick.</p> <p>Only returns a limited subset of the data, such as one stream, which contains the format, and size, and the format, which contains the filename, format, and size.</p> <p>example output (JSON)</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>pathlib.Path</code> <p>The file to get metadata for. Must be a path object</p> required <p>Returns:</p> Type Description <code>typing.Dict[str, typing.Any]</code> <p>A slimmed-down dictionary containing the metadata.</p>"},{"location":"reference/attachment/#niobot.attachment.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(\nfile: typing.Union[str, pathlib.Path],\nmime_type: str = None,\n) -&gt; typing.Dict[str, typing.Any]\n</code></pre> <p>Gets metadata for a file.</p> <p>This will use imagemagick (<code>identify</code>) for images where available, falling back to ffmpeg (<code>ffprobe</code>) for everything else.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>typing.Union[str, pathlib.Path]</code> <p>The file to get metadata for.</p> required <code>mime_type</code> <code>str</code> <p>The mime type of the file. If not provided, it will be detected.</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Dict[str, typing.Any]</code> <p>The metadata for the file. See niobot.get_metadata_ffmpeg and niobot.get_metadata_imagemagick for more information.</p>"},{"location":"reference/attachment/#niobot.attachment.first_frame","title":"first_frame","text":"<pre><code>first_frame(\nfile: str | pathlib.Path, file_format: str = \"webp\"\n) -&gt; bytes\n</code></pre> <p>Gets the first frame of a video file.</p> <p>This function creates a file on disk</p> <p>In order to extract the frame, this function creates a temporary file on disk (or memdisk depending on where your tempdir is). While this file is deleted after the function is done, it is still something to be aware of. For example, if you're (worryingly) low on space, this function may fail to extract the frame due to a lack of space. Or, someone could temporarily access and read the file before it is deleted.</p> <p>This also means that this function may be slow.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | pathlib.Path</code> <p>The file to get the first frame of. Must be a path-like object</p> required <code>file_format</code> <code>str</code> <p>The format to save the frame as. Defaults to webp.</p> <code>'webp'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The first frame of the video in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.generate_blur_hash","title":"generate_blur_hash","text":"<pre><code>generate_blur_hash(\nfile: str | pathlib.Path | io.BytesIO, *parts: int\n) -&gt; str\n</code></pre> <p>Creates a blurhash</p> <p>This function may be resource intensive</p> <p>This function may be resource intensive, especially for large images. You should run this in a thread or process pool.</p> <p>You should also scale any images down in order to increase performance.</p> <p>See: woltapp/blurhash</p>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#niobot.client.NioBot","title":"NioBot","text":"<p>             Bases: <code>nio.AsyncClient</code></p> <p>The main client for NioBot.</p> <p>Parameters:</p> Name Type Description Default <code>homeserver</code> <code>str</code> <p>The homeserver to connect to. e.g. https://matrix-client.matrix.org</p> required <code>user_id</code> <code>str</code> <p>The user ID to log in as. e.g. @user:matrix.org</p> required <code>device_id</code> <code>str</code> <p>The device ID to log in as. e.g. nio-bot</p> <code>'nio-bot'</code> <code>store_path</code> <code>str</code> <p>The path to the store file. Defaults to ./store. Must be a directory.</p> <code>None</code> <code>command_prefix</code> <code>str</code> <p>The prefix to use for commands. e.g. !</p> required <code>case_insensitive</code> <code>bool</code> <p>Whether to ignore case when checking for commands. If True, this lower()s incoming messages for parsing.</p> <code>True</code> <code>global_message_type</code> <p>The message type to default to. Defaults to m.notice</p> required <code>ignore_old_events</code> <p>Whether to simply discard events before the bot's login.</p> required <code>auto_join_rooms</code> <p>Whether to automatically join rooms the bot is invited to.</p> required <code>automatic_markdown_renderer</code> <p>Whether to automatically render markdown in messages when sending/editing.</p> required <code>owner_id</code> <code>str</code> <p>The user ID of the bot owner. If set, only this user can run owner-only commands, etc.</p> <code>None</code>"},{"location":"reference/client/#niobot.client.NioBot.commands","title":"commands  <code>property</code>","text":"<pre><code>commands: typing.Dict[str, Command]\n</code></pre> <p>Returns the internal command register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p> <p>Note</p> <p>Aliases of commands are treated as their own command instance. You will see the same command show up as a value multiple times if it has aliases.</p> <p>You can check if two commands are identical by comparing them (<code>command1instance == command2instance</code>)</p>"},{"location":"reference/client/#niobot.client.NioBot.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: typing.Dict[typing.Type[Module], Module]\n</code></pre> <p>Returns the internal module register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p>"},{"location":"reference/client/#niobot.client.NioBot.latency","title":"latency  <code>staticmethod</code>","text":"<pre><code>latency(\nevent: nio.Event, *, received_at: float = None\n) -&gt; float\n</code></pre> <p>Returns the latency for a given event in milliseconds</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>nio.Event</code> <p>The event to measure latency with</p> required <code>received_at</code> <code>float</code> <p>The optional time the event was received at. If not given, uses the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The latency in milliseconds</p>"},{"location":"reference/client/#niobot.client.NioBot.dispatch","title":"dispatch","text":"<pre><code>dispatch(event_name: str, *args: str, **kwargs: str)\n</code></pre> <p>Dispatches an event to listeners</p>"},{"location":"reference/client/#niobot.client.NioBot.is_old","title":"is_old","text":"<pre><code>is_old(event: nio.Event) -&gt; bool\n</code></pre> <p>Checks if an event was sent before the bot started. Always returns False when ignore_old_evens is False</p>"},{"location":"reference/client/#niobot.client.NioBot.update_read_receipts","title":"update_read_receipts  <code>async</code>","text":"<pre><code>update_read_receipts(room, event)\n</code></pre> <p>part of spec module 11.6</p>"},{"location":"reference/client/#niobot.client.NioBot.process_message","title":"process_message  <code>async</code>","text":"<pre><code>process_message(\nroom: nio.MatrixRoom, event: nio.RoomMessageText\n)\n</code></pre> <p>Processes a message and runs the command it is trying to invoke if any.</p>"},{"location":"reference/client/#niobot.client.NioBot.is_owner","title":"is_owner","text":"<pre><code>is_owner(user_id: str) -&gt; bool\n</code></pre> <p>Checks whether a user is the owner of the bot.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The user ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user is the owner.</p>"},{"location":"reference/client/#niobot.client.NioBot.mount_module","title":"mount_module","text":"<pre><code>mount_module(\nimport_path: str,\n) -&gt; typing.Optional[list[Command]]\n</code></pre> <p>Mounts a module including all of its commands.</p> <p>Must be a subclass of niobot.commands.Module, or else this function will not work.</p> There may not be an event loop running when this function is called. <p>If you are calling this function before you call <code>bot.run()</code>, it is entirely possible that you don't have a running asyncio event loop. If you use the event loop in <code>Module.__init__</code>, you will get an error, and the module will fail the mount.</p> <p>You can get around this by deferring mounting your modules until the <code>bot.on_ready</code> event is fired, at which point not only will the first full sync have completed (meaning the bot has all of its caches populated), but the event loop will be running.</p> <p>Parameters:</p> Name Type Description Default <code>import_path</code> <code>str</code> <p>The import path (such as modules.file), which would be ./modules/file.py in a file tree.</p> required <p>Returns:</p> Type Description <code>typing.Optional[list[Command]]</code> <p>Optional[List[Command]] - A list of commands mounted. None if the module's setup() was called.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>The module path is incorrect of there was another error while importing</p> <code>TypeError</code> <p>The module was not a subclass of Module.</p> <code>ValueError</code> <p>There was an error registering a command (e.g. name conflict)</p>"},{"location":"reference/client/#niobot.client.NioBot.get_command","title":"get_command","text":"<pre><code>get_command(name: str) -&gt; Command | None\n</code></pre> <p>Attempts to retrieve an internal command</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command to retrieve</p> required <p>Returns:</p> Type Description <code>Command | None</code> <p>The command, if found. None otherwise.</p>"},{"location":"reference/client/#niobot.client.NioBot.add_command","title":"add_command","text":"<pre><code>add_command(command: Command) -&gt; None\n</code></pre> <p>Adds a command to the internal register</p> <p>if a name or alias is already registered, this throws a ValueError. Otherwise, it returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.remove_command","title":"remove_command","text":"<pre><code>remove_command(command: Command) -&gt; None\n</code></pre> <p>Removes a command from the internal register.</p> <p>If the command is not registered, this is a no-op.</p>"},{"location":"reference/client/#niobot.client.NioBot.command","title":"command","text":"<pre><code>command(name: str = None, **kwargs: str)\n</code></pre> <p>Registers a command with the bot.</p>"},{"location":"reference/client/#niobot.client.NioBot.on_event","title":"on_event","text":"<pre><code>on_event(event_type: str = None)\n</code></pre> <p>Wrapper that allows you to register an event handler</p>"},{"location":"reference/client/#niobot.client.NioBot.room_send","title":"room_send  <code>async</code>","text":"<pre><code>room_send(\nroom_id: str,\nmessage_type: str,\ncontent: dict,\ntx_id: str | None = None,\nignore_unverified_devices: bool = True,\n) -&gt; nio.RoomSendResponse | nio.RoomSendError\n</code></pre> <p>Send a message to a room. Wrapper. See :meth:<code>nio.AsyncClient.room_send</code> for more information.</p>"},{"location":"reference/client/#niobot.client.NioBot.get_cached_message","title":"get_cached_message","text":"<pre><code>get_cached_message(\nevent_id: str,\n) -&gt; typing.Optional[\ntyping.Tuple[nio.MatrixRoom, nio.RoomMessageText]\n]\n</code></pre> <p>Fetches a message from the cache.</p> <p>This returns both the room the message was sent in, and the event itself.</p> <p>If the message is not in the cache, this returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.fetch_message","title":"fetch_message  <code>async</code>","text":"<pre><code>fetch_message(room_id: str, event_id: str)\n</code></pre> <p>Fetches a message from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.wait_for_message","title":"wait_for_message  <code>async</code>","text":"<pre><code>wait_for_message(\nroom_id: str = None,\nsender: str = None,\ncheck: typing.Callable[\n[nio.MatrixRoom, nio.RoomMessageText], typing.Any\n] = None,\n*,\ntimeout: float = None\n) -&gt; typing.Optional[\ntyping.Tuple[nio.MatrixRoom, nio.RoomMessageText]\n]\n</code></pre> <p>Waits for a message, optionally with a filter.</p> <p>If this function times out, asyncio.TimeoutError is raised.</p>"},{"location":"reference/client/#niobot.client.NioBot.generate_mx_reply","title":"generate_mx_reply  <code>staticmethod</code>","text":"<pre><code>generate_mx_reply(\nroom: nio.MatrixRoom, event: nio.RoomMessageText\n) -&gt; str\n</code></pre> <p>Generates a reply string for a given event.</p>"},{"location":"reference/client/#niobot.client.NioBot.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(\nroom: nio.MatrixRoom | str,\ncontent: str = None,\nfile: BaseAttachment = None,\nreply_to: nio.RoomMessageText | str = None,\nmessage_type: str = None,\nclean_mentions: bool = False,\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Sends a message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room to send this message to</p> required <code>content</code> <code>str</code> <p>The content to send. Cannot be used with file.</p> <code>None</code> <code>file</code> <code>BaseAttachment</code> <p>A file to send, if any. Cannot be used with content.</p> <code>None</code> <code>reply_to</code> <code>nio.RoomMessageText | str</code> <p>A message to reply to.</p> <code>None</code> <code>message_type</code> <code>str</code> <p>The message type to send. If none, defaults to NioBot.global_message_type, which itself is <code>m.notice</code> by default.</p> <code>None</code> <code>clean_mentions</code> <code>bool</code> <p>Whether to escape all mentions</p> <code>False</code> <p>Returns:</p> Type Description <code>nio.RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to send, or if the file fails to upload.</p> <code>ValueError</code> <p>You specified neither file nor content.</p>"},{"location":"reference/client/#niobot.client.NioBot.edit_message","title":"edit_message  <code>async</code>","text":"<pre><code>edit_message(\nroom: nio.MatrixRoom | str,\nmessage: nio.Event | str,\ncontent: str,\n*,\nmessage_type: str = None,\nclean_mentions: bool = False\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Edit an existing message. You must be the sender of the message.</p> <p>You also cannot edit messages that are attachments.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>message</code> <code>nio.Event | str</code> <p>The message to edit.</p> required <code>content</code> <code>str</code> <p>The new content of the message.</p> required <code>message_type</code> <code>str</code> <p>The new type of the message (i.e. m.text, m.notice. Defaults to client.global_message_type)</p> <code>None</code> <code>clean_mentions</code> <code>bool</code> <p>Whether to escape all mentions</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>TypeError</code> <p>If the message is not text.</p>"},{"location":"reference/client/#niobot.client.NioBot.delete_message","title":"delete_message  <code>async</code>","text":"<pre><code>delete_message(\nroom: nio.MatrixRoom | str,\nmessage_id: nio.RoomMessage | str,\nreason: str = None,\n) -&gt; nio.RoomRedactResponse\n</code></pre> <p>Delete an existing message. You must be the sender of the message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>message_id</code> <code>nio.RoomMessage | str</code> <p>The message to delete.</p> required <code>reason</code> <code>str</code> <p>The reason for deleting the message.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>MessageException</code> <p>If the message fails to delete.</p>"},{"location":"reference/client/#niobot.client.NioBot.add_reaction","title":"add_reaction  <code>async</code>","text":"<pre><code>add_reaction(\nroom: nio.MatrixRoom | str,\nmessage: nio.RoomMessage | str,\nemoji: str,\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Adds an emoji \"reaction\" to a message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>message</code> <code>nio.RoomMessage | str</code> <p>The event ID or message object to react to.</p> required <code>emoji</code> <code>str</code> <p>The emoji to react with (e.g. <code>\u274c</code> = \u274c)</p> required <p>Returns:</p> Type Description <code>nio.RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to react.</p>"},{"location":"reference/client/#niobot.client.NioBot.redact_reaction","title":"redact_reaction  <code>async</code>","text":"<pre><code>redact_reaction(\nroom: nio.MatrixRoom | str,\nreaction: nio.RoomSendResponse | str,\n)\n</code></pre> <p>Alias for NioBot.delete_message, but more appropriately named for reactions.</p>"},{"location":"reference/client/#niobot.client.NioBot.start","title":"start  <code>async</code>","text":"<pre><code>start(\npassword: str = None,\naccess_token: str = None,\nsso_token: str = None,\n) -&gt; None\n</code></pre> <p>Starts the bot, running the sync loop.</p>"},{"location":"reference/client/#niobot.client.NioBot.run","title":"run","text":"<pre><code>run(\n*,\npassword: str = None,\naccess_token: str = None,\nsso_token: str = None\n) -&gt; None\n</code></pre> <p>Runs the bot, blocking the program until the event loop exists. This should be the last function to be called in your script, as once it exits, the bot will stop running.</p> <p>Note:     This function is literally just asyncio.run(NioBot.start(...)), so you won't have much control over the     asyncio event loop. If you want more control, you should use await NioBot.start(...) instead.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to log in with.</p> <code>None</code> <code>access_token</code> <code>str</code> <p>An existing login token.</p> <code>None</code> <code>sso_token</code> <code>str</code> <p>An SSO token to sign in with.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/commands/","title":"Commands","text":"<p>Using commands and events is the main way to interact with the bot.</p>"},{"location":"reference/commands/#niobot.commands.Argument","title":"Argument","text":"<p>Represents a command argument.</p> Example <pre><code>from niobot import NioBot, command, Argument\nbot = NioBot(...)\n@bot.command(\"echo\", arguments=[Argument(\"message\", str)])\ndef echo(ctx: niobot.Context, message: str):\nawait ctx.respond(message)\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument. Will be used to know which argument to pass to the command callback.</p> required <code>arg_type</code> <code>_T</code> <p>The type of the argument (e.g. str, int, etc. or a custom type)</p> required <code>description</code> <code>str</code> <p>The description of the argument. Will be shown in the auto-generated help command.</p> <code>None</code> <code>default</code> <code>typing.Any</code> <p>The default value of the argument</p> <code>...</code> <code>required</code> <code>bool</code> <p>Whether the argument is required or not. Defaults to True if default is ..., False otherwise.</p> <code>...</code>"},{"location":"reference/commands/#niobot.commands.Argument.internal_parser","title":"internal_parser  <code>staticmethod</code>","text":"<pre><code>internal_parser(\n_: Context, arg: Argument, value: str\n) -&gt; typing.Optional[_T]\n</code></pre> <p>The default parser for the argument. Will try to convert the value to the argument type.</p>"},{"location":"reference/commands/#niobot.commands.Command","title":"Command","text":"<p>Represents a command.</p> Example <p>Note</p> <p>This example uses the <code>command</code> decorator, but you can also use the <code>Command</code> class directly, but you likely won't need to, unless you want to pass a custom command class.</p> <p>All that the <code>@command</code> decorator does is create a <code>Command</code> instance and add it to the bot's commands, while wrapping the function its decorating.</p> <pre><code>from niobot import NioBot, command\nbot = NioBot(...)\n@bot.command(\"hello\")\ndef hello(ctx: niobot.Context):\nawait ctx.respond(\"Hello, %s!\" % ctx.message.sender)\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Will be used to invoke the command.</p> required <code>callback</code> <code>callable</code> <p>The callback to call when the command is invoked.</p> required <code>aliases</code> <code>list[str]</code> <p>The aliases of the command. Will also be used to invoke the command.</p> <code>None</code> <code>description</code> <code>str</code> <p>The description of the command. Will be shown in the auto-generated help command.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the command is disabled or not. If disabled, the command will be hidden on the auto-generated help command, and will not be able to be invoked.</p> <code>False</code> <code>arguments</code> <p>A list of <code>Argument</code> instances. Will be used to parse the arguments given to the command. <code>ctx</code> is always the first argument, regardless of what you put here.</p> required <code>usage</code> <p>A string representing how to use this command's arguments. Will be shown in the auto-generated help. Do not include the command name or your bot's prefix here, only arguments. For example: <code>usage=\"&lt;message&gt; [times]\"</code> will show up as <code>[p][command] &lt;message&gt; [times]</code> in the help command.</p> required <code>hidden</code> <code>bool</code> <p>Whether the command is hidden or not. If hidden, the command will be always hidden on the auto-generated help.</p> <code>False</code>"},{"location":"reference/commands/#niobot.commands.Command.display_usage","title":"display_usage  <code>property</code>","text":"<pre><code>display_usage: str\n</code></pre> <p>Returns the usage string for this command, auto-resolved if not pre-defined</p>"},{"location":"reference/commands/#niobot.commands.Command.autodetect_args","title":"autodetect_args  <code>staticmethod</code>","text":"<pre><code>autodetect_args(callback) -&gt; list[Argument]\n</code></pre> <p>Attempts to auto-detect the arguments for the command, based on the callback's signature</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <p>The function to inspect</p> required <p>Returns:</p> Type Description <code>list[Argument]</code> <p>A list of arguments. <code>self</code>, and <code>ctx</code> are skipped.</p>"},{"location":"reference/commands/#niobot.commands.Command.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if another command's runtime ID is the same as this one's</p>"},{"location":"reference/commands/#niobot.commands.Command.invoke","title":"invoke  <code>async</code>","text":"<pre><code>invoke(ctx: Context) -&gt; typing.Coroutine\n</code></pre> <p>Invokes the current command with the given context</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The current context</p> required <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>Too many/few arguments, or an error parsing an argument.</p> <code>CheckFailure</code> <p>A check failed</p>"},{"location":"reference/commands/#niobot.commands.Module","title":"Module","text":""},{"location":"reference/commands/#niobot.commands.Module.__setup__","title":"__setup__","text":"<pre><code>__setup__()\n</code></pre> <p>Setup function called once by NioBot.mount_module(). Mounts every command discovered.</p>"},{"location":"reference/commands/#niobot.commands.Module.__teardown__","title":"__teardown__","text":"<pre><code>__teardown__()\n</code></pre> <p>Teardown function called once by NioBot.unmount_module(). Removes any command that was mounted.</p>"},{"location":"reference/commands/#niobot.commands.command","title":"command","text":"<pre><code>command(name: str = None, **kwargs: str) -&gt; callable\n</code></pre> <p>Allows you to register commands later on, by loading modules.</p> <p>This differs from NioBot.command() in that commands are not automatically added, you need to load them with bot.mount_module</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Defaults to function.name</p> <code>None</code> <code>kwargs</code> <p>Any key-words to pass to Command</p> <code>{}</code> <p>Returns:</p> Type Description <code>callable</code>"},{"location":"reference/commands/#niobot.commands.check","title":"check","text":"<pre><code>check(\nfunction: typing.Callable[\n[Context],\ntyping.Union[\nbool, typing.Coroutine[None, None, bool]\n],\n],\nname: str = None,\n) -&gt; callable\n</code></pre> <pre><code>Allows you to register checks in modules.\n\n```python\n@niobot.command()\n@niobot.check(my_check_func, name=\"My Check\")\nasync def my_command(ctx: niobot.Context):\n    pass\n```\n\n:param function: The function to register as a check\n:param name: A human-readable name for the check. Defaults to function.__name__\n:return: The decorated function.\n</code></pre> <p>=</p>"},{"location":"reference/commands/#niobot.commands.event","title":"event","text":"<pre><code>event(name: str) -&gt; callable\n</code></pre> <p>Allows you to register event listeners in modules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the event (no <code>on_</code> prefix)</p> required <p>Returns:</p> Type Description <code>callable</code>"},{"location":"reference/context/","title":"Context","text":"<p>For each command invoked, the first argument is always a <code>Context</code> instance, which holds a lot of metadata, and a few utility functions to help you write commands.</p> <p>A lot of the time, these are the three main attributes you'll be using:</p> <ul> <li><code>Context.room</code> (<code>nio.MatrixRoom</code>) - the room the command was invoked in.</li> <li><code>Context.event</code> (<code>nio.RoomMessageText</code>) - the message that invoked this command.</li> <li><code>Context.respond</code> - a utility class to help you respond to the command.</li> </ul>"},{"location":"reference/context/#command-context","title":"Command Context","text":"<p>Event-based context for a command callback</p>"},{"location":"reference/context/#niobot.context.Context.room","title":"room  <code>property</code>","text":"<pre><code>room: nio.MatrixRoom\n</code></pre> <p>The room that the event was dispatched in</p>"},{"location":"reference/context/#niobot.context.Context.client","title":"client  <code>property</code>","text":"<pre><code>client: NioBot\n</code></pre> <p>The current instance of the client</p>"},{"location":"reference/context/#niobot.context.Context.command","title":"command  <code>property</code>","text":"<pre><code>command: Command\n</code></pre> <p>The current command being invoked</p>"},{"location":"reference/context/#niobot.context.Context.args","title":"args  <code>property</code>","text":"<pre><code>args: list[str]\n</code></pre> <p>Each argument given to this command</p>"},{"location":"reference/context/#niobot.context.Context.message","title":"message  <code>property</code>","text":"<pre><code>message: nio.RoomMessageText\n</code></pre> <p>The current message</p>"},{"location":"reference/context/#niobot.context.Context.original_response","title":"original_response  <code>property</code>","text":"<pre><code>original_response: typing.Optional[nio.RoomSendResponse]\n</code></pre> <p>The result of Context.reply(), if it exists.</p>"},{"location":"reference/context/#niobot.context.Context.latency","title":"latency  <code>property</code>","text":"<pre><code>latency: float\n</code></pre> <p>Returns the current event's latency in milliseconds.</p>"},{"location":"reference/context/#niobot.context.Context.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(\ncontent: str = None, file: BaseAttachment = None\n) -&gt; ContextualResponse\n</code></pre> <p>Responds to the current event.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text to reply with</p> <code>None</code> <code>file</code> <code>BaseAttachment</code> <p>A file to reply with</p> <code>None</code> <p>Returns:</p> Type Description <code>ContextualResponse</code>"},{"location":"reference/context/#contextual-response","title":"Contextual Response","text":"<p>Context class for managing replies.</p> <p>Usage of this function is not required, however it is a useful utility.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.message","title":"message  <code>property</code>","text":"<pre><code>message: nio.RoomMessageText | None\n</code></pre> <p>Fetches the current message for this response</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.reply","title":"reply  <code>async</code>","text":"<pre><code>reply(*args) -&gt; ContextualResponse\n</code></pre> <p>Replies to the current response.</p> <p>This does NOT reply to the original invoking message.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>args to pass to send_message</p> <code>()</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>a new ContextualResponse object.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(content: str, **kwargs: str) -&gt; ContextualResponse\n</code></pre> <p>Edits the current response.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The new content to edit with</p> required <code>kwargs</code> <p>Any extra arguments to pass to Client.edit_message</p> <code>{}</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>self</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(reason: str = None) -&gt; None\n</code></pre> <p>Redacts the current response.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>An optional reason for the redaction</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None, as there will be no more response.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#niobot.exceptions.NioBotException","title":"NioBotException","text":"<p>             Bases: <code>Exception</code></p> <p>Base exception for NioBot.</p> <p>Warning</p> <p>In some rare cases, all of <code>exception</code>, <code>response</code> and <code>original</code> may be None.</p> <p>All other exceptions raised by this library will subclass this exception, so at least all the below are always available:</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str | None</code> <p>A simple humanised explanation of the issue, if available.</p> <code>response</code> <code>nio.ErrorResponse | None</code> <p>The response object from the server, if available.</p> <code>exception</code> <code>typing.Union[nio.ErrorResponse, BaseException]</code> <p>The exception that was raised, if available.</p> <code>original</code> <code>nio.ErrorResponse | BaseException | None</code> <p>The original response, or exception if response was not available.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a human-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Returns a developer-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MessageException","title":"MessageException","text":"<p>             Bases: <code>NioBotException</code></p> <p>Exception for message-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.LoginException","title":"LoginException","text":"<p>             Bases: <code>NioBotException</code></p> <p>Exception for login-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaUploadException","title":"MediaUploadException","text":"<p>             Bases: <code>MessageException</code></p> <p>Exception for media-uploading related errors</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaCodecWarning","title":"MediaCodecWarning","text":"<p>             Bases: <code>ResourceWarning</code></p> <p>Warning that is dispatched when a media file is not in a supported codec.</p> <p>You can filter this warning by using <code>warnings.filterwarnings(\"ignore\", category=niobot.MediaCodecWarning)</code></p> <p>Often times, matrix clients are web-based, so they're limited to what the browser can display. This is usually:</p> <ul> <li>h264/vp8/vp9/av1/theora video</li> <li>aac/opus/vorbis/mp3/pcm_* audio</li> <li>jpg/png/webp/avif/gif images</li> </ul>"},{"location":"reference/exceptions/#niobot.exceptions.MetadataDetectionException","title":"MetadataDetectionException","text":"<p>             Bases: <code>MediaUploadException</code></p> <p>Exception raised when metadata detection fails. Most of the time, this is an ffmpeg-related error</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandError","title":"CommandError","text":"<p>             Bases: <code>NioBotException</code></p> <p>Exception subclass for all command invocation related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandNotFoundError","title":"CommandNotFoundError","text":"<p>             Bases: <code>CommandError</code></p> <p>Exception raised when a command is not found.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandPreparationError","title":"CommandPreparationError","text":"<p>             Bases: <code>CommandError</code></p> <p>Exception subclass for errors raised while preparing a command for execution.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandDisabledError","title":"CommandDisabledError","text":"<p>             Bases: <code>CommandPreparationError</code></p> <p>Exception raised when a command is disabled.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandArgumentsError","title":"CommandArgumentsError","text":"<p>             Bases: <code>CommandPreparationError</code></p> <p>Exception subclass for command argument related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandParserError","title":"CommandParserError","text":"<p>             Bases: <code>CommandArgumentsError</code></p> <p>Exception raised when there is an error parsing arguments.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CheckFailure","title":"CheckFailure","text":"<p>             Bases: <code>CommandPreparationError</code></p> <p>Exception raised when a generic check call fails.</p> <p>You should prefer one of the subclass errors over this generic one, or a custom subclass.</p> <p><code>CheckFailure</code> is often raised by the built-in checker when a check returns a falsy value without raising an error.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NotOwner","title":"NotOwner","text":"<p>             Bases: <code>CheckFailure</code></p> <p>Exception raised when the command invoker is not the owner of the bot.</p>"},{"location":"reference/exceptions/#niobot.exceptions.InsufficientPower","title":"InsufficientPower","text":"<p>             Bases: <code>CheckFailure</code></p> <p>Exception raised when the command invoker does not have enough power to run the command.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NotADirectRoom","title":"NotADirectRoom","text":"<p>             Bases: <code>CheckFailure</code></p> <p>Exception raised when the current room is not <code>m.direct</code> (a DM room)</p>"},{"location":"reference/utils/federation/","title":"Federation","text":"<p>There isn't a lot here aside from a homeserver resolver. A lot of the federation is already handled by matrix-nio itself, so there isn't a lot of need for federation-specific utilities.</p>"},{"location":"reference/utils/federation/#niobot.utils.federation.resolve_homeserver","title":"resolve_homeserver  <code>async</code>","text":"<pre><code>resolve_homeserver(domain: str) -&gt; str\n</code></pre> <p>Resolves a given homeserver part to the actual homeserver</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain to crawl</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resolved homeserver</p>"},{"location":"reference/utils/help_command/","title":"The help command","text":"<p><code>NioBot</code> comes with a built-in help command, which can be used to display information about other commands.</p> <p>This built-in command is simple, slick, and most importantly, helpful. It takes one optional argument, <code>command</code>, which changes the output to display information about a specific command. Without this, the help command will list every enabled command, their aliases, a short help string, and a short description about the command (by default, the first line of the docstring).</p> <p>This allows for you to easily just add commands and not have to worry about documenting them outside of simply defining their usage in the command decorator, and a short description in the docstring.</p> An example of the help command with no arguments Source of this sample <p>This is the output of the help command from  EEKIM10/niobot-test</p> <pre><code>?[help|h]: Shows a list of commands for this bot\n?[ytdl|yt|dl|yl-dl|yt-dlp] &lt;url&gt; [format]: Downloads a video from YouTube\n?[quote|q]: Generate a random quote.\n?ping: Shows the roundtrip latency\n?info: Shows information about the bot\n?cud: Creates, updates, and deletes a message\n?upload &lt;type: image|video|audio|file&gt;: Uploads an image\n?hello: Asks for an input\n?version: Shows the version of nio\n?[pretty-print|pp]: Pretty prints given JSON\n?eval: Evaluates Python code\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p> An example of the help command with a specified command name Source of this sample <p>This is the output of the help command from  EEKIM10/niobot-test</p> <pre><code>?[help|h]:\nShows a list of commands for this bot\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p>"},{"location":"reference/utils/help_command/#registering-your-own-help-command","title":"Registering your own help command","text":"<p>If you would like to register your own help command, you need to be aware of the following:</p> <ul> <li>The help command is a command, much like any other command, and is registered as such. You should be aware of  aliases, case sensitivity, command states (e.g. disabled/enabled), etc.</li> <li>A help command is almost always a user's first impression of your bot. You should make sure that it works 100% of the time, is insanely simple to use, and is very helpful. A help command that just says \"You can use command like ?info\" is not helpful at all, and will likely turn many users away.</li> </ul> <p>???+ question Are there any dangers to these help commands?</p>"},{"location":"reference/utils/help_command/#help-command-functions","title":"Help Command functions:","text":""},{"location":"reference/utils/help_command/#niobot.utils.help_command.clean_output","title":"clean_output","text":"<pre><code>clean_output(\ntext: str,\n*,\nescape_user_mentions: bool = True,\nescape_room_mentions: bool = True,\nescape_room_references: bool = False,\nescape_all_periods: bool = False,\nescape_all_at_signs: bool = False,\nescape_method: typing.Callable[[str], str] = None\n) -&gt; str\n</code></pre> <p>Escapes given text and sanitises it, ready for outputting to the user.</p> <p>This should always be used when echoing any sort of user-provided content, as we all know there will be some annoying troll who will just go <code>@room</code> for no apparent reason every 30 seconds.</p> <p>Do not rely on this!</p> <p>This function is not guaranteed to escape all possible mentions, and should not be relied upon to do so. It is only meant to be used as a convenience function for simple commands.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to sanitise</p> required <code>escape_user_mentions</code> <code>bool</code> <p>Escape all @user:homeserver.tld mentions</p> <code>True</code> <code>escape_room_mentions</code> <code>bool</code> <p>Escape all @room mentions</p> <code>True</code> <code>escape_room_references</code> <code>bool</code> <p>Escape all #room:homeserver.tld references</p> <code>False</code> <code>escape_all_periods</code> <code>bool</code> <p>Escape all literal <code>.</code> characters (can be used to escape all links)</p> <code>False</code> <code>escape_all_at_signs</code> <code>bool</code> <p>Escape all literal <code>@</code> characters (can be used to escape all mentions)</p> <code>False</code> <code>escape_method</code> <code>typing.Callable[[str], str]</code> <p>A custom escape method to use instead of the built-in one (which just wraps characters in <code>\\u200b</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The cleaned text</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.format_command_name","title":"format_command_name","text":"<pre><code>format_command_name(command: Command) -&gt; str\n</code></pre> <p>Formats the command name with its aliases if applicable</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.format_command_line","title":"format_command_line","text":"<pre><code>format_command_line(prefix: str, command: Command) -&gt; str\n</code></pre> <p>Formats a command line, including name(s) &amp; usage.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.get_short_description","title":"get_short_description","text":"<pre><code>get_short_description(command: Command) -&gt; str\n</code></pre> <p>Generates a short (&lt;100 characters) help description for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.get_long_description","title":"get_long_description","text":"<pre><code>get_long_description(command: Command) -&gt; str\n</code></pre> <p>Gets the full help text for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.help_command_callback","title":"help_command_callback  <code>async</code>","text":"<pre><code>help_command_callback(ctx: Context)\n</code></pre> <p>Displays help text</p>"},{"location":"reference/utils/parsers/","title":"Parsers","text":"<p>These are a handful of built-in parsers that you can use with <code>niobot.Argument</code>.</p> How do I use these? <p>To use a parser, you simply pass <code>parser=&lt;function&gt;</code> when creating <code>Argument()</code>. For example:</p> <pre><code>from niobot import Argument, command, NioBot\nfrom niobot.utils.parsers import float_parser\nbot = NioBot(...)\n@bot.command(\nname=\"sum\", \narguments=[\nArgument(\"num1\", parser=float_parser),\nArgument(\"num2\", parser=float_parser)\n]\n)\nasync def add_numbers(ctx: Context, num1: float, num2: float):\nawait ctx.respond(\"{!s} + {!s} = {!s}\".format(num1, num2, num1 + num2))\nbot.run(...)\n</code></pre> <p>While this is roughly equivalent to <code>Argument(\"num1\", type=float)</code>, it can be helpful in cases like  json_parser where you need to parse complex types.</p> <p>Tip</p> <p>You can also create your own parsers! See Creating Parsers for more information.</p> <p>This utility modules contains a handful of simple off-the-shelf parser for some basic python types.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.boolean_parser","title":"boolean_parser","text":"<pre><code>boolean_parser(_: Context, __: Context, value: str) -&gt; bool\n</code></pre> <p>Converts a given string into a boolean. Value is lower-cased before being parsed.</p> <p>The following resolves to true: * 1, y, yes, true, on</p> <p>The following resolves to false: * 0, n, no, false, off</p> <p>The following will raise a command argument error: anything else</p> <p>Returns:</p> Type Description <code>bool</code> <p>The parsed boolean</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.float_parser","title":"float_parser","text":"<pre><code>float_parser(_: Context, __: Argument, value: str) -&gt; float\n</code></pre> <p>Converts a given string into a floating point number.</p> <p>Returns:</p> Type Description <code>float</code> <p>A parsed boolean</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.integer_parser","title":"integer_parser","text":"<pre><code>integer_parser(\nallow_floats: bool = False, base: int = 10\n) -&gt; typing.Callable[\n[Context, Argument, str], typing.Union[int, float]\n]\n</code></pre> <p>Converts a given value into an integer, or a float if allowed.</p> <p>Parameters:</p> Name Type Description Default <code>allow_floats</code> <code>bool</code> <p>Whether to allow parsing for floating numbers (decimals). Defaults to False.</p> <code>False</code> <code>base</code> <code>int</code> <p>The base to parse (defaults to base 10, denary)</p> <code>10</code> <p>Returns:</p> Type Description <code>typing.Callable[[Context, Argument, str], typing.Union[int, float]]</code> <p>The parsed number.</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.json_parser","title":"json_parser","text":"<pre><code>json_parser(\n_: Context, __: Argument, value: str\n) -&gt; typing.Union[\nlist, dict, str, int, float, type(None), bool\n]\n</code></pre> <p>Converts a given string into a JSON object.</p> <p>Performance boost</p> <p>If you want this to be fast, you should install orjson. It is a drop-in replacement for the standard library. While the parser will still work without it, it may be slower, especially for larger payloads.</p> <p>Returns:</p> Type Description <code>typing.Union[list, dict, str, int, float, type(None), bool]</code> <p>The parsed JSON object</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid JSON object.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.room_parser","title":"room_parser  <code>async</code>","text":"<pre><code>room_parser(\nctx: Context, arg: Argument, value: str\n) -&gt; nio.MatrixRoom\n</code></pre> <p>Parses a room ID, alias, or matrix.to link into a MatrixRoom object.</p> This parser is async <p>This parser is async, and should be awaited when used manually.</p> <p>Returns:</p> Type Description <code>nio.MatrixRoom</code> <p>The MatrixRoom object</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.event_parser","title":"event_parser","text":"<pre><code>event_parser(\nevent_type: str = None,\n) -&gt; typing.Callable[\n[Context, Argument, str],\ntyping.Coroutine[typing.Any, typing.Any, nio.Event],\n]\n</code></pre> <p>Parses an event reference from either its ID, or matrix.to link.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>The event type to expect (such as m.room.message). If None, any event type is allowed.</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Callable[[Context, Argument, str], typing.Coroutine[typing.Any, typing.Any, nio.Event]]</code> <p>The actual internal (async) parser.</p>"},{"location":"reference/utils/parsers/#creating-parsers","title":"Creating Parsers","text":"<p>Creating your own parser is actually really easy. All the library needs from you is a function that:</p> <ul> <li>Takes <code>niobot.Context</code> as its first argument</li> <li>Takes <code>niobot.Argument</code> as its second argument</li> <li>Takes a <code>str</code>ing (the user's input) as its third argument</li> <li>Returns a sensible value</li> <li>Or, raises CommandArgumentsError with a helpful error message.</li> </ul> <p>Do all of this, and you can very easily just pass this to <code>Argument</code>!</p> <p>For example, if you wanted to take a <code>datetime</code>, you could write your own parser like this:</p> <pre><code>from datetime import datetime\nfrom niobot import Argument, command, NioBot\ndef datetime_parser(ctx: Context, arg: Argument, user_input: str):\ntry:\nreturn datetime.strptime(user_input, \"%Y-%m-%d %H:%M:%S\")\nexcept ValueError:\nraise CommandArgumentsError(\"Invalid datetime format. Expected YYYY-MM-DD HH:MM:SS\")\nbot = NioBot(...)\n@bot.command(name=\"remindme\", arguments=[Argument(\"time\", arg_type=datetime, parser=datetime_parser)])\nasync def remind_me(ctx: Context, time: datetime):\nawait ctx.respond(\"I'll remind you at {}!\".format(time.strftime(\"%c\")))\nbot.run(...)\n</code></pre>"},{"location":"reference/utils/string_view/","title":"String View","text":"<p>This is mostly an internal utility.</p> <p>The ArgumentView is mostly used by the internal command parser to parse arguments. While you will be able to use this yourself, its very unlikely that you'll ever actually need it.</p> <p>This is a work in progress.</p> <p>The string view does a lot of complicated maths and logic to determine arguments. It's not as simple as just splitting the string on every whitespace and calling it an argument, the ArgumentView parser has to check for quotes, escape characters, and more.</p> <p>Due to the complexity of the parser, it's very likely that there are still bugs in the parser. Fixes welcome!</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView","title":"ArgumentView","text":"<p>A parser designed to allow for multi-word arguments and quotes</p> <p>For example, the arguments <code>1 \"2 3\" 4</code> would result in three items in the internal list: <code>1</code>, <code>2 3</code>, and <code>4</code></p> <p>This is most useful when parsing arguments from a command, as it allows for multi-word arguments.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse</p> required"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.eof","title":"eof  <code>property</code>","text":"<pre><code>eof: bool\n</code></pre> <p>Returns whether the parser has reached the end of the string</p> <p>Returns:</p> Type Description <p>Whether the parser has reached the end of the string (cursor is greater than or equal to the length of the string)</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.add_arg","title":"add_arg","text":"<pre><code>add_arg(argument: str) -&gt; None\n</code></pre> <p>Adds an argument to the argument list</p> <p>Parameters:</p> Name Type Description Default <code>argument</code> <code>str</code> <p>The argument to add</p> required <p>Returns:</p> Type Description <code>None</code> <p>none</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.parse_arguments","title":"parse_arguments","text":"<pre><code>parse_arguments() -&gt; ArgumentView\n</code></pre> <p>Main parsing engine.</p> <p>Returns:</p> Type Description <code>ArgumentView</code> <p>self</p>"},{"location":"reference/utils/typing/","title":"Typing helper","text":"<p>This utility module contains one tool: the <code>Typing</code> class. It is internally used in the <code>&lt;send/edit/delete&gt;_message</code> functions of <code>NioBot</code>, but you can use it at any point to send typing events to the chat.</p>"},{"location":"reference/utils/typing/#usage","title":"Usage","text":"<p>Context manager to manage typing notifications.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The <code>NioBot</code> instance</p> required <code>room_id</code> <code>str</code> <p>The room id to send the typing notification to</p> required <code>timeout</code> <code>int</code> <p>The timeout in seconds</p> <code>30</code> <code>persistent</code> <code>bool</code> <p>Whether to send a typing notification every <code>timeout</code> seconds, to keep the typing status active</p> <code>True</code> <p>Warning</p> <p>Nesting <code>Typing</code> instances for one specific room is a bad idea, as when each instance is exited, it stops typing for the given room. For example, the below will not work as expected:</p> <pre><code>from niobot import NioBot, utils\nbot = NioBot(...)\n@bot.command()\nasync def ping(ctx):\nasync with utils.Typing(ctx.client, ctx.room.room_id):\nawait ctx.respond(\"Pong!\")\nbot.run(...)\n</code></pre> <p>This will not work because <code>Context.respond</code> calls <code>NioBot.send_message</code>, and <code>NioBot.send_message</code> creates its own <code>Typing</code> instance. Once <code>ctx.respond</code> returns, the internal <code>Typing</code> instance is destroyed, and the typing event is stopped, as is the behaviour of exiting the context manager. This means that either if on the loop, the upper-most <code>utils.Typing</code> instance will simply just create a new typing notification, or will not (especially if <code>persistent</code> was set to <code>False</code>). This breaks the whole persistence of typing.</p> If you want to use <code>Typing</code> to show that you're processing something: <p>If you want to use <code>Typing</code> to show a user that your bot is \"thinking\", or similar, you should make sure you exit the instance before responding. For example:</p> <pre><code>from niobot import NioBot, Typing\nimport httpx\nbot = NioBot(...)\n@bot.command()\nasync def process(ctx):\n\"\"\"Spends a worryingly long time making a network request.\"\"\"\nasync with Typing(ctx.client, ctx.room.room_id):\nawait httpx.get(\"https://example.com\")\nawait ctx.respond(\"Done!\")\n</code></pre> <p>Be aware that this will cause a momentary blip in the <code>xyz is typing</code> status, but this is unavoidable, simply due to the semi-stateless nature of this context wrapper</p> <p>A potential future solution would be to implement some funky internal lock mechanism and/or just prevent nested <code>Typing</code> instances, but this is not a priority at the moment.</p>"},{"location":"reference/utils/typing/#niobot.utils.typing.Typing.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Starts the typing notification loop, or sends a single typing notification if not persistent.</p>"},{"location":"reference/utils/typing/#niobot.utils.typing.Typing.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc, tb)\n</code></pre> <p>Cancels any existing typing loop under this instance and sends a typing notification to stop typing.</p>"},{"location":"reference/utils/unblock/","title":"Unblock","text":"<p>A common problem developers encounter when working with an asyncio event loop is long blocking code. This can be caused by a number of things, but the most common is a call to a library that is not async-aware, and has many blocking operations (such as <code>requests</code>, or even the built-in <code>open()</code> + <code>read()</code> functions).</p> <p>To alleviate this, NioBot provides an \"unblock\" utility, which is a simple async function that will run any blocking code in the event loop executor, and returns the result, without pausing the event loop. This is equivalent to <code>loop.run_in_executor(None, func, *args, **kwargs)</code>.</p> A good example <p><pre><code>from niobot import NioBot, command\nfrom niobot.utils import run_blocking\nbot = NioBot(...)\n@bot.command(name=\"read\")\nasync def read_file(ctx: Context, filename: str):\nwith open(filename, \"r\") as f:\ncontents = await run_blocking(f.read)\nawait ctx.respond(contents)\nbot.run(...)\n</code></pre> This will read the contents of a file, without blocking the event loop, unlike the following code:</p> A bad example <p><pre><code>    from niobot import NioBot, command\nfrom niobot.utils import run_blocking\nbot = NioBot(...)\n@bot.command(name=\"read\")\nasync def read_file(ctx: Context, filename: str):\nwith open(filename, \"r\") as f:\ncontents = f.read()\nawait ctx.respond(contents)\nbot.run(...)\n</code></pre> This example is bad because it will prevent any other event processing until <code>f.read()</code> finishes, which is really bad if the file is large, or the disk is slow. For example, if you read at 1mb/s, and you have a 10 megabyte file, you will block the event loop for approximately 10 seconds, which means your program cannot do anything in those ten seconds, and as such your bot will appear to be non-functional!</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.run_blocking","title":"run_blocking  <code>async</code>","text":"<pre><code>run_blocking(\nfunction: typing.Callable, *args: Any, **kwargs: Any\n) -&gt; Any\n</code></pre> <p>Takes a blocking function and runs it in a thread, returning the result.</p> <p>You should use this for any long-running functions that may take a long time to respond that are not coroutines that you can await. For example, running a subprocess.</p> Example <pre><code>import asyncio\nimport subprocess\nfrom niobot.utils import run_blocking\nasync def main():\nresult = await run_blocking(subprocess.run, [\"find\", \"*.py\", \"-type\", \"f\"], capture_output=True)\nprint(result)\nasyncio.run(main())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>typing.Callable</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function.</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.force_await","title":"force_await  <code>async</code>","text":"<pre><code>force_await(\nfunction: typing.Union[\ntyping.Callable, typing.Coroutine\n],\n*args: Any,\n**kwargs: Any\n)\n</code></pre> <p>Takes a function, and if it needs awaiting, it will be awaited. If it is a synchronous function, it runs it in the event loop, preventing it from blocking.</p> <p>This is equivalent to (pseudo): <pre><code>if can_await(x):\nawait x\nelse:\nawait run_blocking(x)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>typing.Union[typing.Callable, typing.Coroutine]</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the function.</p>"}]}