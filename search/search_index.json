{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#welcome-to-the-nio-bot-documentation","title":"Welcome to the Nio-Bot Documentation","text":"<p>Warning</p> <p>This documentation is still a work in progress, and is auto-generated from docstrings. If you notice any errors, please open a new issue.</p> <p>Furthermore, the docs are still partially written in sphinx (RST) format. Broken links are to be expected.</p>"},{"location":"#installing","title":"Installing","text":"<p>As this package is not yet on PyPi, you must install from git:</p>"},{"location":"#via-pip","title":"Via pip:","text":"<pre><code>$ pip install git+https://github.com/EEKIM10/niobot.git\n</code></pre>"},{"location":"#in-requirementstxt","title":"In requirements.txt:","text":"<pre><code>niobot[e2ee,cli] @ git+https://github.com/EEKIM10/niobot.giit\n</code></pre>"},{"location":"#cli","title":"CLI","text":"<p>The <code>niobot</code> package comes with a CLI tool, which can be used to create templates, get access tokens, resolve homeservers, and more (in the future).</p> <p>You can install the cli tool with the <code>cli</code> extra. The command itself is <code>niocli</code>.</p>"},{"location":"#version-information","title":"Version information","text":"<p>Version information is found in the <code>__version__.py</code> file, which is created while installing the package.</p> <pre><code>from niobot.__version__ import __version__\nprint(__version__)\n</code></pre>"},{"location":"#logging","title":"Logging","text":"<p>Logging is done using the <code>logging</code> module. The logger is named <code>niobot.&lt;module&gt;</code>. For example:</p> <p><pre><code>import logging\nimport niobot\nlogging.basicConfig(level=logging.INFO)\nbot = niobot.NioBot(...)\nbot.run(...)\n</code></pre> This will now output a bunch of logs to your console, which you can use to debug your bot.</p>"},{"location":"client/","title":"Client","text":""},{"location":"client/#niobot.client.NioBot","title":"NioBot","text":"<p>         Bases: <code>nio.AsyncClient</code></p> <p>The main client for NioBot.</p> <p>Parameters:</p> Name Type Description Default <code>homeserver</code> <code>str</code> <p>The homeserver to connect to. e.g. https://matrix-client.matrix.org</p> required <code>user_id</code> <code>str</code> <p>The user ID to log in as. e.g. @user:matrix.org</p> required <code>device_id</code> <code>str</code> <p>The device ID to log in as. e.g. nio-bot</p> <code>'nio-bot'</code> <code>store_path</code> <code>str</code> <p>The path to the store file. Defaults to ./store. Must be a directory.</p> <code>None</code> <code>command_prefix</code> <code>str</code> <p>The prefix to use for commands. e.g. !</p> required <code>case_insensitive</code> <code>bool</code> <p>Whether to ignore case when checking for commands. If True, this lower()s incoming messages for parsing.</p> <code>True</code> <code>global_message_type</code> <code>str</code> <p>The message type to default to. Defaults to m.notice</p> <code>'m.notice'</code> <code>ignore_old_events</code> <code>bool</code> <p>Whether to simply discard events before the bot's login.</p> <code>True</code> <code>owner_id</code> <code>str</code> <p>The user ID of the bot owner. If set, only this user can run owner-only commands, etc.</p> <code>None</code>"},{"location":"client/#niobot.client.NioBot.commands","title":"commands  <code>property</code>","text":"<pre><code>commands: typing.Dict[str, Command]\n</code></pre> <p>Returns the internal command register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p> <p>Note</p> <p>Aliases of commands are treated as their own command instance. You will see the same command show up as a value multiple times if it has aliases.</p>"},{"location":"client/#niobot.client.NioBot.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: typing.Dict[typing.Type[Module], Module]\n</code></pre> <p>Returns the internal module register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p>"},{"location":"client/#niobot.client.NioBot.latency","title":"latency  <code>staticmethod</code>","text":"<pre><code>latency(\nevent: nio.Event, *, received_at: float = None\n) -&gt; float\n</code></pre> <p>Returns the latency for a given event in milliseconds</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>nio.Event</code> <p>The event to measure latency with</p> required <code>received_at</code> <code>float</code> <p>The optional time the event was received at. If not given, uses the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The latency in milliseconds</p>"},{"location":"client/#niobot.client.NioBot.dispatch","title":"dispatch","text":"<pre><code>dispatch(event_name: str, *args: str, **kwargs: str)\n</code></pre> <p>Dispatches an event to listeners</p>"},{"location":"client/#niobot.client.NioBot.is_old","title":"is_old","text":"<pre><code>is_old(event: nio.Event) -&gt; bool\n</code></pre> <p>Checks if an event was sent before the bot started. Always returns False when ignore_old_evens is False</p>"},{"location":"client/#niobot.client.NioBot.update_read_receipts","title":"update_read_receipts  <code>async</code>","text":"<pre><code>update_read_receipts(room, event)\n</code></pre> <p>part of spec module 11.6</p>"},{"location":"client/#niobot.client.NioBot.process_message","title":"process_message  <code>async</code>","text":"<pre><code>process_message(\nroom: nio.MatrixRoom, event: nio.RoomMessageText\n)\n</code></pre> <p>Processes a message and runs the command it is trying to invoke if any.</p>"},{"location":"client/#niobot.client.NioBot.is_owner","title":"is_owner","text":"<pre><code>is_owner(user_id: str) -&gt; bool\n</code></pre> <p>Checks whether a user is the owner of the bot.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The user ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user is the owner.</p>"},{"location":"client/#niobot.client.NioBot.mount_module","title":"mount_module","text":"<pre><code>mount_module(\nimport_path: str,\n) -&gt; typing.Optional[list[Command]]\n</code></pre> <p>Mounts a module including all of its commands.</p> <p>Must be a subclass of niobot.commands.Module, or else this function will not work.</p> <p>Parameters:</p> Name Type Description Default <code>import_path</code> <code>str</code> <p>The import path (such as modules.file), which would be ./modules/file.py in a file tree.</p> required <p>Returns:</p> Type Description <code>typing.Optional[list[Command]]</code> <p>Optional[List[Command]] - A list of commands mounted. None if the module's setup() was called.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>The module path is incorrect of there was another error while importing</p> <code>TypeError</code> <p>The module was not a subclass of Module.</p> <code>ValueError</code> <p>There was an error registering a command (e.g. name conflict)</p>"},{"location":"client/#niobot.client.NioBot.get_command","title":"get_command","text":"<pre><code>get_command(name: str) -&gt; Command | None\n</code></pre> <p>Attempts to retrieve an internal command</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command to retrieve</p> required <p>Returns:</p> Type Description <code>Command | None</code> <p>The command, if found. None otherwise.</p>"},{"location":"client/#niobot.client.NioBot.add_command","title":"add_command","text":"<pre><code>add_command(command: Command) -&gt; None\n</code></pre> <p>Adds a command to the internal register</p> <p>if a name or alias is already registered, this throws a ValueError. Otherwise, it returns None.</p>"},{"location":"client/#niobot.client.NioBot.remove_command","title":"remove_command","text":"<pre><code>remove_command(command: Command) -&gt; None\n</code></pre> <p>Removes a command from the internal register.</p> <p>If the command is not registered, this is a no-op.</p>"},{"location":"client/#niobot.client.NioBot.command","title":"command","text":"<pre><code>command(name: str = None, **kwargs: str)\n</code></pre> <p>Registers a command with the bot.</p>"},{"location":"client/#niobot.client.NioBot.on_event","title":"on_event","text":"<pre><code>on_event(event_type: str = None)\n</code></pre> <p>Wrapper that allows you to register an event handler</p>"},{"location":"client/#niobot.client.NioBot.room_send","title":"room_send  <code>async</code>","text":"<pre><code>room_send(\nroom_id: str,\nmessage_type: str,\ncontent: dict,\ntx_id: str | None = None,\nignore_unverified_devices: bool = True,\n) -&gt; nio.RoomSendResponse | nio.RoomSendError\n</code></pre> <p>Send a message to a room. Wrapper. See :meth:<code>nio.AsyncClient.room_send</code> for more information.</p>"},{"location":"client/#niobot.client.NioBot.get_cached_message","title":"get_cached_message","text":"<pre><code>get_cached_message(\nevent_id: str,\n) -&gt; typing.Optional[\ntyping.Tuple[nio.MatrixRoom, nio.RoomMessageText]\n]\n</code></pre> <p>Fetches a message from the cache.</p> <p>This returns both the room the message was sent in, and the event itself.</p> <p>If the message is not in the cache, this returns None.</p>"},{"location":"client/#niobot.client.NioBot.fetch_message","title":"fetch_message  <code>async</code>","text":"<pre><code>fetch_message(room_id: str, event_id: str)\n</code></pre> <p>Fetches a message from the server.</p>"},{"location":"client/#niobot.client.NioBot.wait_for_message","title":"wait_for_message  <code>async</code>","text":"<pre><code>wait_for_message(\nroom_id: str = None,\nsender: str = None,\ncheck: typing.Callable[\n[nio.MatrixRoom, nio.RoomMessageText], typing.Any\n] = None,\n*,\ntimeout: float = None\n) -&gt; typing.Optional[\ntyping.Tuple[nio.MatrixRoom, nio.RoomMessageText]\n]\n</code></pre> <p>Waits for a message, optionally with a filter.</p> <p>If this function times out, asyncio.TimeoutError is raised.</p>"},{"location":"client/#niobot.client.NioBot.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(\nroom: nio.MatrixRoom | str,\ncontent: str = None,\nfile: MediaAttachment = None,\nreply_to: nio.RoomMessageText | str = None,\nmessage_type: str = None,\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Sends a message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room to send this message to</p> required <code>content</code> <code>str</code> <p>The content to send. Cannot be used with file.</p> <code>None</code> <code>file</code> <code>MediaAttachment</code> <p>A file to send, if any. Cannot be used with content.</p> <code>None</code> <code>reply_to</code> <code>nio.RoomMessageText | str</code> <p>A message to reply to.</p> <code>None</code> <code>message_type</code> <code>str</code> <p>The message type to send. If none, defaults to NioBot.global_message_type, which itself is <code>m.notice</code> by default.</p> <code>None</code> <p>Returns:</p> Type Description <code>nio.RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to send, or if the file fails to upload.</p> <code>ValueError</code> <p>You specified neither file nor content.</p>"},{"location":"client/#niobot.client.NioBot.edit_message","title":"edit_message  <code>async</code>","text":"<pre><code>edit_message(\nroom: nio.MatrixRoom | str,\nevent_id: nio.Event | str,\ncontent: str,\n*,\nmessage_type: str = None\n) -&gt; nio.RoomSendResponse\n</code></pre> <p>Edit an existing message. You must be the sender of the message.</p> <p>You also cannot edit messages that are attachments.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>event_id</code> <code>nio.Event | str</code> <p>The message to edit.</p> required <code>content</code> <code>str</code> <p>The new content of the message.</p> required <code>message_type</code> <code>str</code> <p>The new type of the message (i.e. m.text, m.notice. Defaults to client.global_message_type)</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>TypeError</code> <p>If the message is not text.</p>"},{"location":"client/#niobot.client.NioBot.delete_message","title":"delete_message  <code>async</code>","text":"<pre><code>delete_message(\nroom: nio.MatrixRoom | str,\nmessage_id: nio.RoomMessage | str,\nreason: str = None,\n) -&gt; nio.RoomRedactResponse\n</code></pre> <p>Delete an existing message. You must be the sender of the message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>nio.MatrixRoom | str</code> <p>The room the message is in.</p> required <code>message_id</code> <code>nio.RoomMessage | str</code> <p>The message to delete.</p> required <code>reason</code> <code>str</code> <p>The reason for deleting the message.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p>"},{"location":"client/#niobot.client.NioBot.start","title":"start  <code>async</code>","text":"<pre><code>start(\npassword: str = None,\naccess_token: str = None,\nsso_token: str = None,\n) -&gt; None\n</code></pre> <p>Starts the bot, running the sync loop.</p>"},{"location":"client/#niobot.client.NioBot.run","title":"run","text":"<pre><code>run(\n*,\npassword: str = None,\naccess_token: str = None,\nsso_token: str = None\n) -&gt; None\n</code></pre> <p>Runs the bot, blocking the program until the event loop exists. This should be the last function to be called in your script, as once it exits, the bot will stop running.</p> <p>Note:     This function is literally just asyncio.run(NioBot.start(...)), so you won't have much control over the     asyncio event loop. If you want more control, you should use await NioBot.start(...) instead.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The password to log in with.</p> <code>None</code> <code>access_token</code> <code>str</code> <p>An existing login token.</p> <code>None</code> <code>sso_token</code> <code>str</code> <p>An SSO token to sign in with.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"commands/","title":"Commands","text":"<p>Using commands and events is the main way to interact with the bot.</p>"},{"location":"commands/#niobot.commands.Argument","title":"Argument","text":"<p>Represents a command argument.</p> Example <pre><code>from niobot import NioBot, command, Argument\nbot = NioBot(...)\n@bot.command(\"echo\", arguments=[Argument(\"message\", str)])\ndef echo(ctx: niobot.Context, message: str):\nawait ctx.respond(message)\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument. Will be used to know which argument to pass to the command callback.</p> required <code>arg_type</code> <code>_T</code> <p>The type of the argument (e.g. str, int, etc. or a custom type)</p> required <code>description</code> <code>str</code> <p>The description of the argument. Will be shown in the auto-generated help command.</p> <code>None</code> <code>default</code> <code>typing.Any</code> <p>The default value of the argument</p> <code>Ellipsis</code> <code>required</code> <code>bool</code> <p>Whether the argument is required or not. Defaults to True if default is ..., False otherwise.</p> <code>Ellipsis</code>"},{"location":"commands/#niobot.commands.Argument.internal_parser","title":"internal_parser  <code>staticmethod</code>","text":"<pre><code>internal_parser(\n_: Context, arg: Argument, value: str\n) -&gt; typing.Optional[_T]\n</code></pre> <p>The default parser for the argument. Will try to convert the value to the argument type.</p>"},{"location":"commands/#niobot.commands.Command","title":"Command","text":"<p>Represents a command.</p> Example <p>Note</p> <p>This example uses the <code>command</code> decorator, but you can also use the <code>Command</code> class directly, but you likely won't need to, unless you want to pass a custom command class.</p> <p>All that the <code>@command</code> decorator does is create a <code>Command</code> instance and add it to the bot's commands, while wrapping the function its decorating.</p> <pre><code>from niobot import NioBot, command\nbot = NioBot(...)\n@bot.command(\"hello\")\ndef hello(ctx: niobot.Context):\nawait ctx.respond(\"Hello, %s!\" % ctx.message.sender)\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Will be used to invoke the command.</p> required <code>callback</code> <code>callable</code> <p>The callback to call when the command is invoked.</p> required <code>aliases</code> <code>list[str]</code> <p>The aliases of the command. Will also be used to invoke the command.</p> <code>None</code> <code>description</code> <code>str</code> <p>The description of the command. Will be shown in the auto-generated help command.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the command is disabled or not. If disabled, the command will be hidden on the auto-generated help command, and will not be able to be invoked.</p> <code>False</code> <code>arguments</code> <p>A list of <code>Argument</code> instances. Will be used to parse the arguments given to the command. <code>ctx</code> is always the first argument, regardless of what you put here.</p> required <code>usage</code> <p>A string representing how to use this command's arguments. Will be shown in the auto-generated help. Do not include the command name or your bot's prefix here, only arguments.</p> required"},{"location":"commands/#niobot.commands.Command.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if another command's runtime ID is the same as this one's</p>"},{"location":"commands/#niobot.commands.Command.invoke","title":"invoke","text":"<pre><code>invoke(ctx: Context)\n</code></pre> <p>Invokes the current command with the given context</p>"},{"location":"commands/#niobot.commands.Module","title":"Module","text":""},{"location":"commands/#niobot.commands.Module.__setup__","title":"__setup__","text":"<pre><code>__setup__()\n</code></pre> <p>Setup function called once by NioBot.mount_module(). Mounts every command discovered.</p>"},{"location":"commands/#niobot.commands.Module.__teardown__","title":"__teardown__","text":"<pre><code>__teardown__()\n</code></pre> <p>Teardown function called once by NioBot.unmount_module(). Removes any command that was mounted.</p>"},{"location":"commands/#niobot.commands.command","title":"command","text":"<pre><code>command(name: str = None, **kwargs: str) -&gt; callable\n</code></pre> <p>Allows you to register commands later on, by loading modules.</p> <p>This differs from NioBot.command() in that commands are not automatically added, you need to load them with bot.mount_module</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Defaults to function.name</p> <code>None</code> <code>kwargs</code> <p>Any key-words to pass to Command</p> <code>{}</code> <p>Returns:</p> Type Description <code>callable</code>"},{"location":"commands/#niobot.commands.event","title":"event","text":"<pre><code>event(name: str) -&gt; callable\n</code></pre> <p>Allows you to register event listeners in modules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the event (no <code>on_</code> prefix)</p> required <p>Returns:</p> Type Description <code>callable</code>"},{"location":"context/","title":"Context","text":"<p>For each command invoked, the first argument is always a <code>Context</code> instance, which holds a lot of metadata, and a few utility functions to help you write commands.</p> <p>A lot of the time, these are the three main attributes you'll be using:</p> <ul> <li><code>Context.room</code> (<code>nio.MatrixRoom</code>) - the room the command was invoked in.</li> <li><code>Context.event</code> (<code>nio.RoomMessageText</code>) - the message that invoked this command.</li> <li><code>Context.respond</code> - a utility class to help you respond to the command.</li> </ul>"},{"location":"context/#command-context","title":"Command Context","text":"<p>Event-based context for a command callback</p>"},{"location":"context/#niobot.context.Context.room","title":"room  <code>property</code>","text":"<pre><code>room: nio.MatrixRoom\n</code></pre> <p>The room that the event was dispatched in</p>"},{"location":"context/#niobot.context.Context.client","title":"client  <code>property</code>","text":"<pre><code>client: NioBot\n</code></pre> <p>The current instance of the client</p>"},{"location":"context/#niobot.context.Context.command","title":"command  <code>property</code>","text":"<pre><code>command: Command\n</code></pre> <p>The current command being invoked</p>"},{"location":"context/#niobot.context.Context.args","title":"args  <code>property</code>","text":"<pre><code>args: list[str]\n</code></pre> <p>Each argument given to this command</p>"},{"location":"context/#niobot.context.Context.message","title":"message  <code>property</code>","text":"<pre><code>message: nio.RoomMessageText\n</code></pre> <p>The current message</p>"},{"location":"context/#niobot.context.Context.original_response","title":"original_response  <code>property</code>","text":"<pre><code>original_response: typing.Optional[nio.RoomSendResponse]\n</code></pre> <p>The result of Context.reply(), if it exists.</p>"},{"location":"context/#niobot.context.Context.latency","title":"latency  <code>property</code>","text":"<pre><code>latency: float\n</code></pre> <p>Returns the current event's latency in milliseconds.</p>"},{"location":"context/#niobot.context.Context.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(\ncontent: str = None, file: MediaAttachment = None\n) -&gt; ContextualResponse\n</code></pre> <p>Responds to the current event.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text to reply with</p> <code>None</code> <code>file</code> <code>MediaAttachment</code> <p>A file to reply with</p> <code>None</code> <p>Returns:</p> Type Description <code>ContextualResponse</code>"},{"location":"context/#contextual-response","title":"Contextual Response","text":"<p>Context class for managing replies.</p> <p>Usage of this function is not required, however it is a useful utility.</p>"},{"location":"context/#niobot.context.ContextualResponse.message","title":"message  <code>property</code>","text":"<pre><code>message: nio.RoomMessageText | None\n</code></pre> <p>Fetches the current message for this response</p>"},{"location":"context/#niobot.context.ContextualResponse.reply","title":"reply  <code>async</code>","text":"<pre><code>reply(*args) -&gt; ContextualResponse\n</code></pre> <p>Replies to the current response.</p> <p>This does NOT reply to the original invoking message.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>args to pass to send_message</p> <code>()</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>a new ContextualResponse object.</p>"},{"location":"context/#niobot.context.ContextualResponse.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(content: str, **kwargs: str) -&gt; ContextualResponse\n</code></pre> <p>Edits the current response.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The new content to edit with</p> required <code>kwargs</code> <p>Any extra arguments to pass to Client.edit_message</p> <code>{}</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>self</p>"},{"location":"context/#niobot.context.ContextualResponse.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(reason: str = None) -&gt; None\n</code></pre> <p>Redacts the current response.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>An optional reason for the redaction</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None, as there will be no more response.</p>"},{"location":"exceptions/","title":"Exceptions","text":""},{"location":"exceptions/#niobot.exceptions.NioBotException","title":"NioBotException","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception for NioBot.</p> <p>Warning</p> <p>In some rare cases, all of <code>exception</code>, <code>response</code> and <code>original</code> may be None.</p> <p>All other exceptions raised by this library will subclass this exception, so at least all the below are always available:</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str | None</code> <p>A simple humanised explanation of the issue, if available.</p> <code>response</code> <code>nio.ErrorResponse | None</code> <p>The response object from the server, if available.</p> <code>exception</code> <code>typing.Union[nio.ErrorResponse, Exception]</code> <p>The exception that was raised, if available.</p> <code>original</code> <code>nio.ErrorResponse | Exception | None</code> <p>The original response, or exception if response was not available.</p>"},{"location":"exceptions/#niobot.exceptions.NioBotException.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a human-readable version of the exception.</p>"},{"location":"exceptions/#niobot.exceptions.NioBotException.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Returns a developer-readable version of the exception.</p>"},{"location":"exceptions/#niobot.exceptions.MessageException","title":"MessageException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for message-related errors.</p>"},{"location":"exceptions/#niobot.exceptions.LoginException","title":"LoginException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for login-related errors.</p>"},{"location":"exceptions/#niobot.exceptions.MediaUploadException","title":"MediaUploadException","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception for media-uploading related errors</p>"},{"location":"exceptions/#niobot.exceptions.CommandError","title":"CommandError","text":"<p>         Bases: <code>NioBotException</code></p> <p>Exception subclass for all command invocation related errors.</p>"},{"location":"exceptions/#niobot.exceptions.CommandDisabledError","title":"CommandDisabledError","text":"<p>         Bases: <code>CommandError</code></p> <p>Exception raised when a command is disabled.</p>"},{"location":"exceptions/#niobot.exceptions.CommandArgumentsError","title":"CommandArgumentsError","text":"<p>         Bases: <code>CommandError</code></p> <p>Exception subclass for command argument related errors.</p>"},{"location":"exceptions/#niobot.exceptions.CommandParserError","title":"CommandParserError","text":"<p>         Bases: <code>CommandArgumentsError</code></p> <p>Exception raised when there is an error parsing arguments.</p>"},{"location":"utils/help_command/","title":"The help command","text":"<p><code>NioBot</code> comes with a built-in help command, which can be used to display information about other commands.</p> <p>This built-in command is simple, slick, and most importantly, helpful. It takes one optional argument, <code>command</code>, which changes the output to display information about a specific command. Without this, the help command will list every enabled command, their aliases, a short help string, and a short description about the command (by default, the first line of the docstring).</p> <p>This allows for you to easily just add commands and not have to worry about documenting them outside of simply defining their usage in the command decorator, and a short description in the docstring.</p> An example of the help command with no arguments Source of this sample <p>This is the output of the help command from  EEKIM10/niobot-test</p> <pre><code>?[help|h]: Shows a list of commands for this bot\n?[ytdl|yt|dl|yl-dl|yt-dlp] &lt;url&gt; [format]: Downloads a video from YouTube\n?[quote|q]: Generate a random quote.\n?ping: Shows the roundtrip latency\n?info: Shows information about the bot\n?cud: Creates, updates, and deletes a message\n?upload &lt;type: image|video|audio|file&gt;: Uploads an image\n?hello: Asks for an input\n?version: Shows the version of nio\n?[pretty-print|pp]: Pretty prints given JSON\n?eval: Evaluates Python code\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p> An example of the help command with a specified command name Source of this sample <p>This is the output of the help command from  EEKIM10/niobot-test</p> <pre><code>?[help|h]:\nShows a list of commands for this bot\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p>"},{"location":"utils/help_command/#registering-your-own-help-command","title":"Registering your own help command","text":"<p>If you would like to register your own help command, you need to be aware of the following:</p> <ul> <li>The help command is a command, much like any other command, and is registered as such. You should be aware of  aliases, case sensitivity, command states (e.g. disabled/enabled), etc.</li> <li>A help command is almost always a user's first impression of your bot. You should make sure that it works 100% of the time, is insanely simple to use, and is very helpful. A help command that just says \"You can use command like ?info\" is not helpful at all, and will likely turn many users away.</li> </ul> <p>???+ question Are there any dangers to these help commands?</p>"},{"location":"utils/help_command/#help-command-functions","title":"Help Command functions:","text":""},{"location":"utils/help_command/#niobot.utils.help_command.clean_output","title":"clean_output","text":"<pre><code>clean_output(\ntext: str,\n*,\nescape_user_mentions: bool = True,\nescape_room_mentions: bool = True,\nescape_room_references: bool = False,\nescape_all_periods: bool = False,\nescape_all_at_signs: bool = False,\nescape_method: typing.Callable[[str], str] = None\n) -&gt; str\n</code></pre> <p>Escapes given text and sanitises it, ready for outputting to the user.</p> <p>This should always be used when echoing any sort of user-provided content, as we all know there will be some annoying troll who will just go <code>@room</code> for no apparent reason every 30 seconds.</p> <p>Do not rely on this!</p> <p>This function is not guaranteed to escape all possible mentions, and should not be relied upon to do so. It is only meant to be used as a convenience function for simple commands.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to sanitise</p> required <code>escape_user_mentions</code> <code>bool</code> <p>Escape all @user:homeserver.tld mentions</p> <code>True</code> <code>escape_room_mentions</code> <code>bool</code> <p>Escape all @room mentions</p> <code>True</code> <code>escape_room_references</code> <code>bool</code> <p>Escape all #room:homeserver.tld references</p> <code>False</code> <code>escape_all_periods</code> <code>bool</code> <p>Escape all literal <code>.</code> characters (can be used to escape all links)</p> <code>False</code> <code>escape_all_at_signs</code> <code>bool</code> <p>Escape all literal <code>@</code> characters (can be used to escape all mentions)</p> <code>False</code> <code>escape_method</code> <code>typing.Callable[[str], str]</code> <p>A custom escape method to use instead of the built-in one (which just wraps characters in <code>\\u200b</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The cleaned text</p>"},{"location":"utils/help_command/#niobot.utils.help_command.format_command_name","title":"format_command_name","text":"<pre><code>format_command_name(command: Command) -&gt; str\n</code></pre> <p>Formats the command name with its aliases if applicable</p>"},{"location":"utils/help_command/#niobot.utils.help_command.format_command_line","title":"format_command_line","text":"<pre><code>format_command_line(prefix: str, command: Command) -&gt; str\n</code></pre> <p>Formats a command line, including name(s) &amp; usage.</p>"},{"location":"utils/help_command/#niobot.utils.help_command.get_short_description","title":"get_short_description","text":"<pre><code>get_short_description(command: Command) -&gt; str\n</code></pre> <p>Generates a short (&lt;100 characters) help description for a command.</p>"},{"location":"utils/help_command/#niobot.utils.help_command.get_long_description","title":"get_long_description","text":"<pre><code>get_long_description(command: Command) -&gt; str\n</code></pre> <p>Gets the full help text for a command.</p>"},{"location":"utils/help_command/#niobot.utils.help_command.help_command_callback","title":"help_command_callback  <code>async</code>","text":"<pre><code>help_command_callback(ctx: Context)\n</code></pre> <p>Displays help text</p>"},{"location":"utils/parsers/","title":"Parsers","text":"<p>These are a handful of built-in parsers that you can use with <code>niobot.Argument</code>.</p> <p>This utility modules contains a handful of simple off-the-shelf parser for some basic python types.</p>"},{"location":"utils/parsers/#niobot.utils.parsers.boolean_parser","title":"boolean_parser","text":"<pre><code>boolean_parser(_: Context, __: Context, value: str) -&gt; bool\n</code></pre> <p>Converts a given string into a boolean. Value is lower-cased before being parsed.</p> <p>The following resolves to true:     1, y, yes, true, on</p> <p>The following resolves to false:     0, n, no, false, off</p> <p>The following will raise a command argument error: anything else</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The parsed boolean</p>"},{"location":"utils/parsers/#niobot.utils.parsers.float_parser","title":"float_parser","text":"<pre><code>float_parser(_: Context, __: Argument, value: str) -&gt; float\n</code></pre> <p>Converts a given string into a floating point number.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <code>Argument</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>float</code> <p>A parsed boolean</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid number.</p>"},{"location":"utils/parsers/#niobot.utils.parsers.integer_parser","title":"integer_parser","text":"<pre><code>integer_parser(\nallow_floats: bool = False, base: int = 10\n) -&gt; typing.Callable[\n[Context, Argument, str], typing.Union[int, float]\n]\n</code></pre> <p>Converts a given value into an integer, or a float if allowed.</p> <p>Parameters:</p> Name Type Description Default <code>allow_floats</code> <code>bool</code> <p>Whether to allow parsing for floating numbers (decimals). Defaults to False.</p> <code>False</code> <code>base</code> <code>int</code> <p>The base to parse (defaults to base 10, denary)</p> <code>10</code> <p>Returns:</p> Type Description <code>typing.Callable[[Context, Argument, str], typing.Union[int, float]]</code> <p>The parsed number.</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid number.</p>"},{"location":"utils/parsers/#niobot.utils.parsers.json_parser","title":"json_parser","text":"<pre><code>json_parser(\n_: Context, __: Argument, value: str\n) -&gt; typing.Union[\nlist, dict, str, int, float, type(None), bool\n]\n</code></pre> <p>Converts a given string into a JSON object.</p> <p>.. Note::     If you want this to be fast, you should install orjson. It is a drop-in replacement for the standard library.     While the parser will still work without it, it may be slower, especially for larger payloads.</p> <p>Parameters:</p> Name Type Description Default <code>_</code> <code>Context</code> <p>Value is unused</p> required <code>__</code> <code>Argument</code> <p>Value is unused</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>typing.Union[list, dict, str, int, float, type(None), bool]</code> <p>The parsed JSON object</p> <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>if the value is not a valid JSON object.</p>"},{"location":"utils/typing/","title":"Typing helper","text":"<p>This utility module contains one tool: the <code>Typing</code> class. It is internally used in the <code>&lt;send/edit/delete&gt;_message</code> functions of <code>NioBot</code>, but you can use it at any point to send typing events to the chat.</p>"},{"location":"utils/typing/#usage","title":"Usage","text":"<p>Context manager to manage typing notifications.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The <code>NioBot</code> instance</p> required <code>room_id</code> <code>str</code> <p>The room id to send the typing notification to</p> required <code>timeout</code> <code>int</code> <p>The timeout in seconds</p> <code>30</code> <code>persistent</code> <code>bool</code> <p>Whether to send a typing notification every <code>timeout</code> seconds, to keep the typing status active</p> <code>True</code> <p>Warning</p> <p>Nesting <code>Typing</code> instances for one specific room is a bad idea, as when each instance is exited, it stops typing for the given room. For example, the below will not work as expected:</p> <pre><code>from niobot import NioBot, utils\nbot = NioBot(...)\n@bot.command()\nasync def ping(ctx):\nasync with utils.Typing(ctx.client, ctx.room.room_id):\nawait ctx.respond(\"Pong!\")\nbot.run(...)\n</code></pre> <p>This will not work because <code>Context.respond</code> calls <code>NioBot.send_message</code>, and <code>NioBot.send_message</code> creates its own <code>Typing</code> instance. Once <code>ctx.respond</code> returns, the internal <code>Typing</code> instance is destroyed, and the typing event is stopped, as is the behaviour of exiting the context manager. This means that either if on the loop, the upper-most <code>utils.Typing</code> instance will simply just create a new typing notification, or will not (especially if <code>persistent</code> was set to <code>False</code>). This breaks the whole persistence of typing.</p> If you want to use <code>Typing</code> to show that you're processing something: <p>If you want to use <code>Typing</code> to show a user that your bot is \"thinking\", or similar, you should make sure you exit the instance before responding. For example:</p> <pre><code>from niobot import NioBot, Typing\nimport httpx\nbot = NioBot(...)\n@bot.command()\nasync def process(ctx):\n\"\"\"Spends a worryingly long time making a network request.\"\"\"\nasync with Typing(ctx.client, ctx.room.room_id):\nawait httpx.get(\"https://example.com\")\nawait ctx.respond(\"Done!\")\n</code></pre> <p>Be aware that this will cause a momentary blip in the <code>xyz is typing</code> status, but this is unavoidable, simply due to the semi-stateless nature of this context wrapper</p> <p>A potential future solution would be to implement some funky internal lock mechanism and/or just prevent nested <code>Typing</code> instances, but this is not a priority at the moment.</p>"},{"location":"utils/typing/#niobot.utils.typing.Typing.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Starts the typing notification loop, or sends a single typing notification if not persistent.</p>"},{"location":"utils/typing/#niobot.utils.typing.Typing.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc, tb)\n</code></pre> <p>Cancels any existing typing loop under this instance and sends a typing notification to stop typing.</p>"}]}